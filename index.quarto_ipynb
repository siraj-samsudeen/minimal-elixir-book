{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: Minimal Elixir to be Productive in Phoenix\n",
        "jupyter: python3\n",
        "---\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "## Python Pro meets AI Mentor to Learn Elixir using 80/20 Rule\n",
        "\n",
        "\n",
        "## Preface\n",
        "\n",
        "I stared my professional life as a developer in the year 2000, but left the programming world after my MBA and moved into Management Consulting. Nearly after a 15-year gap, I came back to programming to build an app for a personal pet project. I learnt Python and built an application using Django in a very short time and maintained it for 3 years. I liked a lot of things about Django - though it was complicated to get started, it made me very productive. But I wanted my front-end to be more responsive and avoid full page loads - So, I started evaluating JS SPA frameworks like React. \n",
        "\n",
        "I have evaluated a lot of JS frameworks - both frontend (React, Angular, Vue, Svelte) and fullstack (NextJS, Remix, RedwoodJS) to see whether I could settle on using Javascript only for the entire stack. But most of the approaches in the JS world seemed too complicated. I was really shocked to see the amount of code one has to write to get a basic Counter working in React. And the amount of boilerplate in NextJS to make it a full-stack app.\n",
        "\n",
        "So, it was a refreshing change to see HTMX and how simple and declarative it was to get a lot of the reactivity on the front-end without too much boilerplate code. I was pleased to read the Hypermedia systems book to realise how the web was originally envisioned and how that original vision solved many of the problems that are faced by the API-driven front-end based approach for full-stack applications. I also evaluated FastAPI and was pleased to see how many things they have done to make the developer experience better compared to Django. So, when I saw that FastHTML took the ideas of FastAPI and combined with HTMX, I jumped in, learnt it and started to port my application. It was such a nice feeling to be able to iterate on UI code using Jupyter notebook. We built the app relatively quickly and moved it into production. That is when we started facing the challenges with FastHTML.\n",
        "\n",
        "Being a new framework, it did not have many of the things I have taken for granted in Django - database migrations, admin app, authentication, well-thought testing framework, etc. So, One day I was researching on the best way to organize the different HTTP routes to standardize our approach for testing using Playwright and pytest combo. And then I was chatting with Claude AI to see what other frameworks are done. \n",
        "\n",
        "That's when I discovered Ruby on Rails conventions. I was amazed to realize that all the architectural decisions I was wrestling with had been thoughtfully codified in Rails for over a decade.\n",
        "I have heard a lot of positive things about Rails, but I have also heard that people moved out of Rails as it did not scale well and there was no way to write front-ends like React. I watched a demo of Ruby on Rails 8 and was impressed by the framework. So, I started studying Ruby to build a sample app in Ruby to evaluate it.\n",
        "  \n",
        "When I started reading the Ruby on Rails book, the preface was written by Derek Sivers, who I met a few years back. I wrote to him saying that finally I am looking at the language that he loves a lot - Ruby. But surprisingly, Derek asked to look at Phoenix instead of Ruby on Rails. I was not in favour of learning another new language. Though I have heard very positive things about Phoenix, I did not have a very positive opinion of Elixir as I tried it out a year back in a Functional Programming week, by Exercism. I felt that the language had too many annoying rules and the syntax was clumsy. So, I was not willing to even consider Elixir as part of my choices. But for some reason, Derek gently pushed to relook at Elixir, mentioning that Dave Thomas, who wrote the book on Rails told him that Phoenix is a better web development framework these days. Hmmm. I really did not want to leave the lure of Rails as I was already reading one of the great books on Ruby on Rails. Then to confront the confirmation bias in me, I decided to give myself a week to see whether Elixir is really that bad, as per my initial quick judgement and whether Phoenix is really that good, like what everyone keeps saying.\n",
        "\n",
        "  I bought the 2 most recommended books on Elixir - Programming Elixir 1.6 by Dave Thomas and Elixir in Action by Saša Jurić. I also bought the Elixir and Phoenix video courses by Pragmatic Studio. The video courses were phenomenal as they launched into building a HTTP server from scratch in Elixir and I loved every bit of it - though it was complex, I was, in some sense prepared for it, as I had built a HTTP server from scratch in python last year through CodeCrafters.io. So, I was able to see how Elixir fares in comparison to Python for building a HTTP server from scratch. This is when I realised the elegance behind some of the abstractions in Elixir.\n",
        "\n",
        "After a week, I started to like Elixir and I slowly started to see the wisdom behind some of the annoying rules (here is an example - you have to use a dot to call a function defined in local scope, but for a function defined in a module, a dot is not needed - I wondered why?). I watched through the full Elixir and OTP course, but found it was just too much information for me as my main aim was to understand Phoenix, rather than being an Elixir pro. Then I jumped into Phoenix course and the Elixir syntax did not seem magical for me and I was able to easily follow the Phoenix course.\n",
        "\n",
        "I am not a video guy - after watching videos for a few days, I felt that I needed some reading material. But I went back to reading the books I have bought - but both books dived deep into Elixir. Elixir in Action took the typical approach of starting with covering all the data types, then variables, etc. Though Dave Thomas skipped a lot of such material, a lot of concepts he discussed were not really needed for me to work in Phoenix. I came across a few blog posts where people have documented how they have learnt Elixir and Phoenix and they mentioned all these materials plus some more. So, it looks like we have to do a PhD level study in Elixir before starting on Phoenix.\n",
        "\n",
        "I wished there was a book which applied the 80/20 rule to learning Elixir - 80% of the outcomes come from 20% of effort. So, I wanted to identify the core 20% of the Elixir language that can help a newcomer to be productive in Elixir in a week. My goal is for a newcomer to Elixir to be productive in Phoenix as quickly as possible - yes, there might be parts that he/she may not understand well, but that is OK, they can always pick these up, by going to these excellent deep dives offered by the materials I have mentioned above, when they feel they need to master Elixir. I hate theory - that these are the data types and these operators, etc.  - I want to learn by doing small, progressively complex examples that build real understanding.\n",
        "\n",
        "I've designed this book specifically for developers coming to Elixir from Python, using contrast between the two languages to reinforce learning. The exercises incorporate proven learning science principles—spacing, interleaving, and recall testing—to help you build muscle memory for the core language patterns you'll encounter most frequently in Phoenix.\n",
        "\n",
        "My goal is simple: get you productive with Phoenix in a week, not a month. Let us see whether anyone is able to get there in a week. \n",
        "\n",
        "There is one more thing - I am gonna use AI extensively to help me write the book fast. I am using Claude AI directly and through the excellent SolveIt platform from AnswerDotAI. This book is structured as a conversation between a python pro and AI as Elixir Mentor.\n",
        "\n",
        "## Rules of the game\n",
        "\n",
        "1. You are going act as a seasoned programmer who knows python, JS, and many other OO-based languages. You have worked with Ruby from its early stages and then moved to Elixir. So, you are the veteran who is gonna help me to see things in proper perspective. \n",
        "2. I am a python programmer. Though I know JS well, I have done a lot more work in Python than JS. So, when you are talking to me to explain some of the key ideas in Elixir, you are gonna compare it to Python first and then if needed JS. But keep the JS examples minimal, so that someone without much JS experience can still understand this book.\n",
        "3. This book is going to be a conversation between a mentor (you) and a student (me). We talk things out, and you give me things to do, code to write, other material to read or watch, and I would come back to you with my observations and questions. \n",
        "4. You are also going to question me on whether my understanding is correct by asking me questions, giving me simple yet challenging exercises to see whether I really understood things at a deeper level.\n",
        "5. Whenever you explain any concept, please use simple and concrete examples that a beginner can easily visualise and keep it in his memory. I am aiming this book at people who are new to programming who might have had a brief exposure to Python. If a seasoned python pro reads this book, it should make sense to him and should not bore him to death. \n",
        "6. Keep it minimal - focus on the 20% of the language that will the reader 80% returns on his time invested\n",
        "7. Point out the joyful developer experience in Elixir's design whenever possible.\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "So, where should I start with Elixir?\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Here are 3 key ideas that you will see mentioned a lot in Elixir - we will go through some hands-on exercises to understand them.\n",
        "\n",
        "1. Immutability by default\n",
        "2. Pattern matching\n",
        "3. Piping as way to use Functions for transformations\n",
        "\n",
        "But before we get started, make you have installed `iex` - the interactive Elixir shell running in your system. \n",
        "If you need help, go to this page, install elixir and do the steps mentioned there to say `hello world` interactively in `iex` and by running an elixir code file.\n",
        "[Elixir Installation Guide](https://elixir-lang.org/getting-started/introduction.html)\n",
        "\n",
        "Here is a test to check whether you got iex installed - what happens when you type i \"cat\" in `iex`? \n",
        "\n",
        "## Interactive Elixir Shell\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "here is what I see in my iTerm - I am on a Mac. \n",
        "\n",
        "```elixir\n",
        "iex(38)> i \"cat\"\n",
        "Term\n",
        "  \"cat\"\n",
        "Data type\n",
        "  BitString\n",
        "Byte size\n",
        "  3\n",
        "Description\n",
        "  This is a string: a UTF-8 encoded binary. It's printed surrounded by\n",
        "  \"double quotes\" because all UTF-8 encoded code points in it are printable.\n",
        "Raw representation\n",
        "  <<99, 97, 116>>\n",
        "Reference modules\n",
        "  String, :binary\n",
        "Implemented protocols\n",
        "  Collectable, IEx.Info, Inspect, JSON.Encoder, List.Chars, String.Chars\n",
        "```\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Perfect! I see you have `iex` working correctly. The `i` function gives you information about any value - in this case showing that \"cat\" is a binary (You expected to see string - right? But Elixir calls it binary and you will understand over time why. Don't delve into too much as it is not important - Just remember to map string to binary whenever you have to do something with string).\n",
        "\n",
        "Now just type h and see what you get. You will see a lot of output and you have to scroll up a lot to see the first page. See whether you can find anything related to the previous command you executed in that first page.\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "Yes - I see the help for the `i` command I used - it says `i/1` is a function to introspect any value. A lot of jargons, I guess :). But I got it, but what is that suffix `/1` and `/2` I see quite a bit? \n",
        "\n",
        "```elixir\n",
        "iex(39)> h\n",
        "\n",
        "                                  IEx.Helpers\n",
        "\n",
        "Welcome to Interactive Elixir. You are currently seeing the documentation for\n",
        "the module IEx.Helpers which provides many helpers to make Elixir's shell more\n",
        "joyful to work with.\n",
        "\n",
        "This message was triggered by invoking the helper h(), usually referred to as\n",
        "h/0 (since it expects 0 arguments).\n",
        "\n",
        "You can use the h/1 function to invoke the documentation for any Elixir module\n",
        "or function:\n",
        "\n",
        "    iex> h(Enum)\n",
        "    iex> h(Enum.map)\n",
        "    iex> h(Enum.reverse/1)\n",
        "\n",
        "You can also use the i/1 function to introspect any value you have in the\n",
        "shell:\n",
        "\n",
        "    iex> i(\"hello\")\n",
        "\n",
        "There are many other helpers available, here are some examples:\n",
        "\n",
        "  • b/1             - prints callbacks info and docs for a given module\n",
        "  • c/1             - compiles a file\n",
        "  • c/2             - compiles a file and writes bytecode to the given path\n",
        "  • cd/1            - changes the current directory\n",
        "  • clear/0         - clears the screen\n",
        "  • exports/1       - shows all exports (functions + macros) in a module\n",
        "  • flush/0         - flushes all messages sent to the shell\n",
        "  • h/0             - prints this help message\n",
        "  • h/1             - prints help for the given module, function or macro\n",
        "  • i/0             - prints information about the last value\n",
        "  • i/1             - prints information about the given term\n",
        "```\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Great observation! The `/1` and `/2` notation is how Elixir indicates function arity - another jargon for the number of arguments a function takes. Just note this term `arity` as you will see it used quite a lot in Elixir. \n",
        "\n",
        "For example:\n",
        "- `i/1` means the `i` function that takes exactly 1 argument\n",
        "- `h/1` means the `h` function that takes exactly 1 argument\n",
        "- `h/0` means the `h` function that takes 0 arguments (which is what you just ran)\n",
        "\n",
        "This is important in Elixir because unlike Python, you can have multiple functions with the same name but different number of arguments, and they're considered completely different functions.\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "in python, the same function can't be used again with a different number of arguments - right?\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "That's correct! In Python, you can't have multiple functions with the same name but different numbers of arguments in the same scope.\n",
        "\n",
        "In Python, if you define a function twice, the second definition overwrites the first:\n",
        "\n",
        "```python\n",
        "def greet(name):\n",
        "    return f\"Hello, {name}!\"\n",
        "\n",
        "def greet(name, time_of_day):\n",
        "    return f\"Good {time_of_day}, {name}!\"\n",
        "\n",
        "# Now only the second definition exists\n",
        "# greet(\"Alice\") would raise a TypeError\n",
        "```\n",
        "\n",
        "Python handles variable arguments through default parameters, *args, and **kwargs:\n",
        "\n",
        "```python\n",
        "def greet(name, time_of_day=\"day\", *args, **kwargs):\n",
        "    # Handle different numbers of arguments in one function\n",
        "    pass\n",
        "```\n",
        "\n",
        "In Elixir, these are actually different functions, and the language will select the right one based on the number of arguments you provide. This is a fundamental difference that affects how you design your code. \n",
        "\n",
        "But let us get too deep into those differences now - My main aim now is to familiarize you with the iex shell. So, let us get back to that. \n",
        "\n",
        "Let me summarize - there are 2 ways to access the documentation \n",
        "1. All the documentation of all packages in Elixir including the core packages are available in `hexdocs.pm`. \n",
        "2. IEx’s `h` helper shows offline documentation for modules and functions that are part of Elixir itself or other libraries installed in your current project\n",
        "\n",
        "Compared to basic python REPL or even the colorful ipython, iex is a lot more feature-rich. We will come back to this later on. But I want you to start paying attention to iex and not dismiss as just another command-line utility for the geeks. \n",
        "\n",
        "Before, we close the topic on iex, Let's try this out. Try typing:\n",
        "```\n",
        "h i/1\n",
        "```\n",
        "\n",
        "Then try:\n",
        "```\n",
        "h h\n",
        "```\n",
        "\n",
        "What do you notice about the output of these commands?\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "`i` prints information about the data type of any given term.\n",
        "\n",
        "And `h h` prints the documentation for IEx.Helpers. Here is what I got for `h h`. \n",
        "\n",
        "```elixir\n",
        "iex(40)> h h\n",
        "\n",
        "                                    def h()\n",
        "\n",
        "Prints the documentation for IEx.Helpers.\n",
        "\n",
        "\n",
        "                                defmacro h(term)\n",
        "\n",
        "Prints the documentation for the given module or for the given function/arity\n",
        "pair.\n",
        "\n",
        "## Examples\n",
        "\n",
        "    iex> h(Enum)\n",
        "\n",
        "It also accepts functions in the format function/arity and\n",
        "module.function/arity, for example:\n",
        "\n",
        "    iex> h(receive/1)\n",
        "    iex> h(Enum.all?/2)\n",
        "    iex> h(Enum.all?)\n",
        "```\n",
        "\n",
        "And interestingly, I already see the arity word here. It says `function/arity pair`. But I also see the word `macro` - what is that? I have heard of macro only in Excel, not in programming languagues like Python or JS.\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Good question! Macros in programming languages are quite different from Excel macros.\n",
        "\n",
        "In Elixir (and many other languages), a macro is code that writes code. Think of it as a function that runs at compile time rather than runtime, and it can transform your code before it's actually compiled.\n",
        "\n",
        "Here's a simple way to understand it:\n",
        "- Regular functions: Take data as input, return data as output\n",
        "- Macros: Take code as input, return code as output\n",
        "\n",
        "In Python, you might have encountered decorators, which are somewhat similar in concept but much more limited than Elixir macros.\n",
        "\n",
        "Macros are a powerful feature in Elixir that let you extend the language itself. They're part of what makes Elixir's syntax so clean and expressive. For example, the `if` statement in Elixir is actually a macro, not a built-in language construct!\n",
        "\n",
        "For now, just know that macros exist and are powerful, but we won't need to create our own macros when getting started. We'll use many built-in macros without even realizing it.\n",
        "\n",
        "Let's move on to something more simple as macros is an advanced topic that is outside the core 20% we want to focus. \n",
        "\n",
        "Let us get started with the first concept - pattern matching. Do you remember how destructuring works in python? \n",
        "\n",
        "## Pattern Matching\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "Destructuring (also called unpacking) in Python allows you to assign elements from a list (or any other iterable, if I want to get more precise) to multiple variables in a single statement. \n",
        "\n",
        "```py\n",
        "numbers = [1, 2, 3]\n",
        "a, b, c = numbers\n",
        "print(a, b, c) #> 1, 2, 3\n",
        "```\n",
        "\n",
        "In this example: The list numbers contains three elements. The statement a, b, c = numbers unpacks the list so that a gets the first value, b the second, and c the third.\n",
        "\n",
        "Rule : The number of variables on the left must match the number of elements in the iterable on the right.\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Excellent! You've got a solid understanding of Python's destructuring.\n",
        "\n",
        "In Elixir, we have something similar but rather than calling `=` `assignment operator`, Elixir calls it `match operator` and when an Elixir pro looks at this line, he will say this is NOT an assignment, but pattern matching. It would make you wonder `What?` Let us tackle this one by one, by translating each line from your python code into Elixir equivalent. \n",
        "\n",
        "Now type this first line into iex:\n",
        "\n",
        "```elixir\n",
        "iex> list = [1, 2, 3]\n",
        "```\n",
        "\n",
        "before you press Enter, think about what you expect to see. In python, if you type this into `ipython` what would you see? Try that first and then do the same thing in iex and let me know what you see as the difference. \n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "Since assignment is just a statement, I did not expect anything to be printed in the console and ipython did not print anything. But surprisingly, iex printed the list `[1,2,3]` - why?\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Great observation! This is one of the first differences you'll notice between Python and Elixir.\n",
        "\n",
        "In Elixir, every expression returns a value, and IEx automatically prints that returned value. When you write `list = [1, 2, 3]`, the match operator `=` returns the value on its right side after performing the match.\n",
        "\n",
        "This is actually quite convenient because:\n",
        "\n",
        "1. You can immediately see the result of your operations\n",
        "2. You can chain operations together, since each returns a value\n",
        "3. You get immediate feedback that your code worked as expected\n",
        "\n",
        "To achieve the same effect, in Python, you have to type the variable again:\n",
        "```python\n",
        "In [3]: numbers = [1,2,3]\n",
        "\n",
        "In [4]: numbers\n",
        "Out[4]: [1, 2, 3]\n",
        "```\n",
        "\n",
        "Now, let's try the destructuring part. In Elixir, type:\n",
        "\n",
        "```elixir\n",
        "iex> a, b, c = numbers\n",
        "```\n",
        "\n",
        "What do you expect to happen? And what actually happens when you run it?\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "Hmm. that is mean - iex screamed at me in anger - here is what I see, but the error stacktrace is just 4 lines - that is nice :)\n",
        "\n",
        "```elixir\n",
        "iex(2)> a, b, c = numbers\n",
        "** (SyntaxError) invalid syntax found on iex:2:2:\n",
        "    error: syntax error before: ','\n",
        "    │\n",
        "  2 │ a, b, c = numbers\n",
        "    │  ^\n",
        "    │\n",
        "    └─ iex:2:2\n",
        "    (iex 1.18.3) lib/iex/evaluator.ex:299: IEx.Evaluator.parse_eval_inspect/4\n",
        "    (iex 1.18.3) lib/iex/evaluator.ex:189: IEx.Evaluator.loop/1\n",
        "    (iex 1.18.3) lib/iex/evaluator.ex:34: IEx.Evaluator.init/5\n",
        "    (stdlib 6.2.2) proc_lib.erl:329: :proc_lib.init_p_do_apply/3\n",
        "```\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "So, you thought that you're gonna learn by executing everything perfectly. Had I given you the proper syntax, I am sure you will have NOT noticed that there is a closing and opening bracket around `a, b, c` . By making a mistake, now you learnt that things are different from python here. To me, this is the essence of learning by doing - you actively experiment by doing things, off the track, to see how Elixir works. \n",
        "So you got to experience how Elixir reports error. Even though it is NOT clear why there is a syntax error before the comma, you can see that the stack trace and the overall error reporting is much shorter and sweeter compared to Python. \n",
        "\n",
        "But before we see the right syntax to make this statement work, let us understand how this ACTUALLY works in python. Most people don't know how it works. Once you know how it works, you will see the elegance behind the design of Elixir. \n",
        "\n",
        "### Python's unpacking process:\n",
        "\n",
        "```python\n",
        "numbers = [1, 2, 3]\n",
        "a, b, c = numbers\n",
        "```\n",
        "\n",
        "1. **Left side**: a, b, c creates a tuple as if you have written like this: `(a, b, c)`\n",
        "2. **Right side**: numbers is a list, but can be any iterable (tuple, string, etc.)\n",
        "3. **Python unpacks**: Takes the iterable and assigns each element to corresponding positions in the tuple pattern\n",
        "\n",
        "So, python is creating a tuple, behind the scenes, and uses it to unpack. But Elixir's philosophy is being explicit. Hence, it wants you to specify things explicitly - so, you have to use a list on the left side too. So, can you fix the issue yourself? \n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "I went ahead and fixed the issue, and it was easy enough. \n",
        "\n",
        "```elixir\n",
        "[a, b, c] = numbers\n",
        "```\n",
        "\n",
        "I really like the fact that Elixir is returning the value on the right-hand side. I can easily see the values assigned to `a,b and c` without explicitly printing like in python. \n",
        "\n",
        "Then I thought of trying on my own to actively figure out what should be the equivalent of the print statement and I just tried `print(a,b,c)` and it reported to me - By readign the error, I understand that there is no print function which accepts 3 arguments - maybe, Elixir wants me to be explicit here. So, I tried just `print(a)` and even that did not work - that is annoying. \n",
        "```\n",
        "iex(7)> print(a,b,c)\n",
        "error: undefined function print/3 (there is no such import)\n",
        "└─ iex:7\n",
        "\n",
        "** (CompileError) cannot compile code (errors have been logged)\n",
        "```\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Excellent! You fixed the pattern matching syntax perfectly - `[a, b, c] = list` is exactly right. You're absolutely right - Elixir wants you to be explicit with the square brackets `[a, b, c]` to match the structure on both sides.\n",
        "\n",
        "And I love that you're experimenting on your own!\n",
        "\n",
        "\n",
        "And you're discovering another key difference: Elixir doesn't have a `print` function like Python. Instead, you use `IO.puts` for printing. IO is the module in which puts function is defined - puts means put the string\n",
        "\n",
        "> AI is thinking of sending a message to Jose Valim (the creator of Elixir): Dear Jose, `IO.puts` (s for string) seems inconsistent in Elixir as strings are called binary - So, why NOT `IO.putb` for putting the binary. And why not use the word `print` as it is simple enough for everyone to understand?\n",
        "\n",
        "Ok, sorry I got lost in my thoughts. Try this:\n",
        "\n",
        "```elixir\n",
        "IO.puts(a)\n",
        "```\n",
        "But notice how you can also just type the variable name and see its value, as in ipython:\n",
        "```elixir\n",
        "a\n",
        "```\n",
        "\n",
        "What happens? And then see if you can figure out how to display all three values.\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "No I could not figure it out. I tried `IO.puts(a,b)` and it reported an error about FunctionClause - that is weird - I was expecting it to say that print/2 is not found. \n",
        "```\n",
        "iex(8)> IO.puts(a, b)\n",
        "** (FunctionClauseError) no function clause matching in IO.puts/2\n",
        "\n",
        "    The following arguments were given to IO.puts/2:\n",
        "\n",
        "        # 1\n",
        "        1\n",
        "\n",
        "        # 2\n",
        "        2\n",
        "\n",
        "    Attempted function clauses (showing 1 out of 1):\n",
        "\n",
        "        def puts(device, item) when is_atom(device) or is_pid(device)\n",
        "\n",
        "    (elixir 1.18.3) lib/io.ex:311: IO.puts/2\n",
        "    iex:8: (file)\n",
        "```\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Great experimentation! You've discovered something important about Elixir's error reporting.\n",
        "\n",
        "The `FunctionClauseError` tells us that `IO.puts/2` exists (a function that takes 2 arguments), but your arguments don't match what it expects. Function Clause is a key concept you need to understand as it falls under the core 20%. But we will come back to it later. \n",
        "\n",
        "Looking at the error, it shows that `IO.puts/2` expects the first argument to be a device (like `:stdio` for standard output), not just any value.\n",
        "\n",
        "So `IO.puts` has two versions:\n",
        "- `IO.puts/1` - prints to standard output \n",
        "- `IO.puts/2` - prints to a specific device. So, you when you called this function/arity combination, Elixir was expecting a device as the first arg. But you passed it a number. But don't worry about it for now - we will come back to this idea later.\n",
        "\n",
        "Did you try to pass a list to IO.puts and see what it does? \n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "It printed something weird - why? \n",
        "```\n",
        "iex(9)> IO.puts([a,b,c])\n",
        "^!^\"^#\n",
        ":ok\n",
        "```\n",
        "and BTW, what was that `:ok` that was on a new line. I noticed it when the value of `a` was printed too.\n",
        "```\n",
        "iex> IO.puts(a)\n",
        "1\n",
        ":ok\n",
        "```\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Great observations! You've hit two important Elixir concepts:\n",
        "\n",
        "  \n",
        "\n",
        "**The `:ok`**: This is called an atom in Elixir - Atoms (starting with `:`) are like symbols - constants that represent themselves. This is another key concept you need to understand as a lot of standard library functions return atoms to indicate success or failure.  Here, `IO.puts` is returning this atom to indicate that it has done its job successfully. \n",
        "\n",
        "Remember how every expression in Elixir returns a value? `IO.puts` does its job (printing), then returns the atom `:ok` to indicate success. It's like a Python function that returns `None`, but here it is more explicit about success.\n",
        "  \n",
        "\n",
        "**The weird output `^!^\"^#`**: When you pass a list of integers to `IO.puts`, Elixir tries to interpret them as character codes. The numbers 1, 2, 3 correspond to ASCII control characters, which display as those strange symbols. This is Elixir being helpful (sometimes too helpful!) by assuming you want to print characters.\n",
        "  \n",
        "Here is the way to think about `IO.puts` - use it when you want to print human-readable strings only. When you pass a list to `IO.puts`, Elixir is thinking that the list contains the codepoints for each of the characters you want to print. In `iex`, type `i \"cat\"` now and see what it prints as the internal representation. You will see something like `<<99, 97, 116>>` - this the delimiter that Elixir uses to denote the start and end of binary. It will also tell you the reason why it uses double-quotes:\n",
        "\n",
        "  \n",
        "\n",
        "> This is a string: a UTF-8 encoded binary. It's printed surrounded by \"double quotes\" because all UTF-8 encoded code points in it are printable.\n",
        "\n",
        "  \n",
        "\n",
        "Sidenote: if you don't understand what UTF-8 means, and you really have a lot of time on your hand, then try reading this looooong but wonderfully accessible explanation of all the complexity behind UTF-8.\n",
        "\n",
        "[The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets (No Excuses!) – Joel on Software](https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/)\n",
        "\n",
        "  \n",
        "\n",
        "Now try `IO.puts([99, 97, 116])` and see what gets printed? you got the `cat` - right? So, that is how `cat` is stored internally.\n",
        "\n",
        "  \n",
        "\n",
        "If you want to print a list or any other complex data structure, use IO.inspect. Just do a quick `h IO.inspect` and see what it says. The documentation is wonderful as it gives very clear example usages. Now try to print the values of `a,b,c` using IO.inspect and see whether you can succeed.\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "Yes I was able to succeeed.\n",
        "```\n",
        "iex(16)> IO.inspect([a,b,c])\n",
        "[1, 2, 3]\n",
        "[1, 2, 3]\n",
        "```\n",
        "I guess that the first line is the actual printing and the 2nd line is the same value returned by IO.inspect - but why does it do it?\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Exactly right! You've figured out the pattern.\n",
        "\n",
        "`IO.inspect` is designed to be used in pipelines and debugging, so it prints the value AND returns it unchanged. This lets you \"peek\" at values in the middle of a computation without disrupting the flow. But we have not really discussed the concept of piping yet in Elixir. \n",
        "\n",
        "Let us get back to printing again - to print the values of `a,b,c` like in python, you should use string interpolation. \n",
        "```elixir\n",
        "IO.puts(\"#{a} #{b} #{c}\")\n",
        "```\n",
        "\n",
        "And this is very similar to python f-strings, though python has more than 1 way to do string interpolation, Elixir has only one way. Pay attention to the extra pound symbol for each interpolated variable, compared to the python syntax. Try typing it by hand to get used to this as you will use it a lot.\n",
        "\n",
        "```python\n",
        "# f-strings (Python 3.6+)\n",
        "print(f\"{a} {b} {c}\")\n",
        "```\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "Yes I tried it and it works\n",
        "```\n",
        "iex(16)> IO.inspect([a,b,c])\n",
        "[1, 2, 3]\n",
        "[1, 2, 3]\n",
        "iex(17)> IO.puts(\"#{a} #{b} #{c}\")\n",
        "1 2 3\n",
        ":ok\n",
        "iex(18)> IO.puts(a)\n",
        "1\n",
        ":ok\n",
        "```\n",
        "\n",
        "when I tried IO.puts(a) and you said that puts means put the string, but a is NOT a string. It is an integer and you said that Elixir is explicit :)\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Excellent catch! You've spotted an inconsistency in my explanation. You're absolutely right to question this.\n",
        "\n",
        "`IO.puts` is actually more flexible than I initially described. It can handle different data types by converting them to strings automatically. When you pass an integer like `a` (which is 1), Elixir converts it to the string \"1\" before printing.\n",
        "\n",
        "This is one of those cases where Elixir is being helpful rather than strictly explicit. The function is designed to \"do what you mean\" for common printing tasks.\n",
        "\n",
        "If Elixir were truly strict about only accepting strings, you'd have to write:\n",
        "```elixir\n",
        "IO.puts(Integer.to_string(a))\n",
        "```\n",
        "\n",
        "But that would be quite verbose for such a common operation.\n",
        "\n",
        "So you've discovered an important nuance: Elixir balances explicitness with practicality. It's explicit about data structures (like requiring `[a, b, c]` instead of `a, b, c`), but more forgiving with common operations like printing.\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "Ok - we have covered a lot of ground and my head is spinning. Can we summarize?\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Absolutely! Let's summarize what you've learned so far:\n",
        "\n",
        "## Key Concepts Covered\n",
        "\n",
        "**1. Pattern Matching vs Assignment**\n",
        "- Elixir uses `=` as a \"match operator\", not assignment\n",
        "- Must be explicit with structure: `[a, b, c] = list` (not `a, b, c = list`)\n",
        "- Always returns the value on the right side\n",
        "\n",
        "**2. IEx Interactive Shell**\n",
        "- Every expression returns a value (unlike Python REPL)\n",
        "- `h` for help, `i` for inspecting data types\n",
        "- Function arity notation: `function_name/number_of_arguments`\n",
        "\n",
        "**3. Printing and Output**\n",
        "- `IO.puts` for human-readable output (converts types automatically)\n",
        "- `IO.inspect` for debugging (prints AND returns the value)\n",
        "- String interpolation: `\"#{variable}\"` (similar to Python f-strings, but pay attention to the extra weight of the pound symbol)\n",
        "\n",
        "**4. Key Differences from Python**\n",
        "- Every expression returns a value\n",
        "- Atoms like `:ok` indicate status\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "that is great - please show me the python and Elixir code that we have walked through side-by-side to go over it once more.\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Here's the side-by-side comparison of what we've covered:\n",
        "\n",
        "## Creating and Pattern Matching Lists\n",
        "\n",
        "**Python:**\n",
        "```python\n",
        "numbers = [1, 2, 3]        # Assignment, no output\n",
        "a, b, c = numbers          # Destructuring (implicit tuple creation)\n",
        "```\n",
        "\n",
        "**Elixir:**\n",
        "```elixir\n",
        "list = [1, 2, 3]           # Pattern matching, returns [1, 2, 3]\n",
        "[a, b, c] = list           # Pattern matching, explicit structure\n",
        "```\n",
        "\n",
        "## Printing Values\n",
        "\n",
        "**Python:**\n",
        "```python\n",
        "print(a)                   # Prints: 1\n",
        "print(f\"{a} {b} {c}\")      # Prints: 1 2 3\n",
        "print([a, b, c])           # Prints: [1, 2, 3]\n",
        "```\n",
        "\n",
        "**Elixir:**\n",
        "```elixir\n",
        "IO.puts(a)                 # Prints: 1, returns: :ok\n",
        "IO.puts(\"#{a} #{b} #{c}\")  # Prints: 1 2 3, returns: :ok\n",
        "IO.inspect([a, b, c])      # Prints: [1, 2, 3], returns: [1, 2, 3]\n",
        "```\n",
        "\n",
        "Notice how Elixir always shows you what each expression returns, while Python's assignment statements return nothing.\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "Great - now, give me a little exercise to put what I have learnt to use. Maybe, I can try pattern matching a list of words. Give me the python code for me to translate into Elixir.\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Perfect! Here's a Python exercise for you to translate:\n",
        "\n",
        "**Python code to translate:**\n",
        "```python\n",
        "fruits = [\"apple\", \"banana\", \"cherry\"]\n",
        "first, second, third = fruits\n",
        "print(f\"I like {first} the most!\")\n",
        "```\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "Yes, I succeeded and here is my code\n",
        "```elixir\n",
        "fruits = [\"apple\", \"banana\", \"cherry\"]\n",
        "[first, second, third] = fruits\n",
        "IO.puts(\"I like #{first} the most!\")\n",
        "```\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Excellent work! You've translated it perfectly. Your Elixir code shows you understand:\n",
        "\n",
        "✅ Pattern matching with explicit list structure `[first, second, third]`  \n",
        "✅ String interpolation with `#{first}`  \n",
        "✅ Using `IO.puts` for output  \n",
        "\n",
        "Now let's test your understanding with a slightly trickier question:\n",
        "\n",
        "How will you translate the following python code into Elixir:\n",
        "```python\n",
        "print('All my fruits:', fruits)\n",
        "#> All my fruits: ['apple', 'banana', 'cherry']\n",
        "```\n",
        "Hint: type `h inspect` and see what it says. \n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "Haha...That was not a tough question at all. Here is my Elixir code:\n",
        "```\n",
        "IO.puts(\"All my fruits: #{inspect(fruits)}\")\n",
        "```\n",
        "But what is the difference between IO.inspect and plain inspect? I am confused.\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Great job! You nailed it perfectly.\n",
        "\n",
        "The difference is subtle but important:\n",
        "\n",
        "- `inspect/1` - A function that converts any data structure to a string representation (but doesn't print anything)\n",
        "- `IO.inspect/1` - Prints the data structure AND returns it unchanged\n",
        "\n",
        "So when you use `inspect(fruits)` inside string interpolation, you're converting the list to a string first, then that string gets interpolated into your message.\n",
        "\n",
        "Mental model:\n",
        "\n",
        "> `inspect` = convert to string (like Python's str() or repr())\n",
        "> `IO.inspect` = print and return (like Python's print() but returns the value)\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "Ok I understand that - but we started this discussion on pattern matching saying this is a match operator and not an assignment operator. So, how does assignment work in Elixir?\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Excellent question! This gets to the heart of why Elixir calls `=` as the `match operator` rather than `assignment`.\n",
        "\n",
        "Let's start with our familiar numbers list.\n",
        "\n",
        "We started with:\n",
        "```elixir\n",
        "numbers = [1, 2, 3]\n",
        "[a, b, c] = numbers\n",
        "```\n",
        "\n",
        "Now, what if we wanted to match just the first element? Try this:\n",
        "```elixir\n",
        "[first] = [1]\n",
        "```\n",
        "This pattern matches a list with exactly one element, binding `first` to `1`.\n",
        "\n",
        "Now, here's the key insight: when you write `x = 5`, this is really just pattern matching with the simplest possible pattern - a single variable! It's like matching a \"list\" with one element, but without the brackets.\n",
        "\n",
        "So \"assignment\" in Elixir is actually just pattern matching where:\n",
        "- Left side: a single variable pattern\n",
        "- Right side: a single value\n",
        "\n",
        "In Elixir, there's no traditional \"assignment\" like in Python. Everything is pattern matching, but it can *look* like assignment in simple cases.\n",
        "\n",
        "When you write `x = 5`, What's really happening is: \"Does the pattern `x` match the value `5`?\" Since `x` has not been declared before, Elixir will match the two sides by binding `x` to `5`. If x already has a value, Elixir will still match the value by rebinding `x` to `5`. So, in a sense, this is similar to assignment and reassignment in python. \n",
        "\n",
        "But here's where it gets interesting. Try this in iex:\n",
        "```elixir\n",
        "x = 5    # x is now bound to 5\n",
        "5 = x   # What do you think happens here?\n",
        "```\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "It just returned the right side value - which is 5, as expected. \n",
        "But I was expecting it to throw an error as assignment flows from right to left in almost all languages I have worked, starting from C to Java to Python and even JS.\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Exactly! You've discovered the fundamental difference between assignment and pattern matching.\n",
        "\n",
        "In assignment-based languages (Python, Java, etc.), `5 = x` would be a syntax error because you can't assign to a literal value.\n",
        "\n",
        "But in Elixir, `5 = x` means: \"Does the pattern `5` match the value stored in `x`?\" Since `x` contains `5`, the match succeeds and returns `5`.\n",
        "\n",
        "This is why Elixir calls it the \"match operator\" - it's checking if both sides can be made to match, not flowing data from right to left.\n",
        "\n",
        "Try this experiment to see the difference:\n",
        "```elixir\n",
        "x = 5\n",
        "6 = x\n",
        "```\n",
        "\n",
        "What do you think will happen now? And why?\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "I get a match error - it makes sense as 6 is not equal to 5\n",
        "```\n",
        "iex(35)> 6=x\n",
        "** (MatchError) no match of right hand side value: 5\n",
        "    (stdlib 6.2.2) erl_eval.erl:667: :erl_eval.expr/6\n",
        "    iex:35: (file)\n",
        "```\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Perfect! You've grasped the core concept of pattern matching.\n",
        "\n",
        "The error `no match of right hand side value: 5` tells us exactly what happened: Elixir tried to match the pattern `6` with the value `5`, and they don't match, so it failed.\n",
        "\n",
        "This is fundamentally different from assignment because:\n",
        "- **Assignment**: Always succeeds (overwrites the variable)\n",
        "- **Pattern matching**: Can fail if the patterns don't match\n",
        "\n",
        "This makes Elixir code much more robust - you can use pattern matching to ensure your data has the structure you expect, and the program will crash early if it doesn't, rather than silently continuing with wrong data.\n",
        "\n",
        "Now you understand why `=` is called the match operator! It's not moving data from right to left - it's checking if both sides can be made to match.\n",
        "\n",
        "Now let us take a detour to understand the real meaning of `=` in Elixir. \n",
        "\n",
        "## Detour - Real meaning of `=` Assignment Operator\n",
        "\n",
        "Here is an excerpt from Dave Thomas' book on Elixir:  \n",
        "> \"Joe Armstrong, Erlang's creator, compares the equals sign in Erlang to that used in algebra. When you write the equation **x = a + 1**, you are not assigning the value of **a + 1** to **x**. Instead you're simply asserting that the expressions **x** and **a + 1** have the same value. If you know the value of **x**, you can work out the value of **a**, and vice versa.\n",
        ">\n",
        ">\n",
        "> His point is that you had to unlearn the algebraic meaning of = when you first came across assignment in imperative programming languages. Now's the time to un-unlearn it.\"\n",
        "\n",
        "when I had read this, I did NOT really understand what Joe Armstrong was saying as I have almost forgotten the real meaning of equals in algebra in the course of my programming career. So, I turned to the newly baked Claude 4 and asked it to explain what this statement means and the whole explanation below, is Claude has given me (with a little bit of nudging, of course :). \n",
        "\n",
        "### Mathematical Equality (What You Learned First)\n",
        "```\n",
        "x = a + 1\n",
        "```\n",
        "This equation works **both ways**:\n",
        "- If `a = 5`, then `x = 6`\n",
        "- If `x = 6`, then `a = 5`\n",
        "- It's a **statement of equality** - both sides have the same value\n",
        "\n",
        "### Programming Assignment (What You Had to Learn)\n",
        "```python\n",
        "x = a + 1  # Python\n",
        "```\n",
        "This only works **one direction**:\n",
        "- Takes value of `a`, adds 1, stores result in `x`\n",
        "- You **cannot** write `a + 1 = x` (SyntaxError!)\n",
        "- It's an **action**: \"compute and store\"\n",
        "\n",
        "### Elixir Pattern Matching (Back to Mathematics!)\n",
        "```elixir\n",
        "x = a + 1  # If a is bound, x gets bound to a + 1\n",
        "a + 1 = x  # If x is bound, assert that x equals a + 1\n",
        "```\n",
        "This works **both directions** like algebra!\n",
        "\n",
        "## The \"Unlearning\" Journey\n",
        "\n",
        "1. **Childhood**: You learned `x = 5 + 1` means \"x equals 6\"\n",
        "2. **Programming school**: You **unlearned** this - `=` now means \"assignment\"\n",
        "3. **Elixir**: Time to **un-unlearn** - `=` goes back to meaning \"equals\"\n",
        "\n",
        "## Side-by-Side Comparison\n",
        "\n",
        "| Context | Expression | Meaning | Bidirectional? |\n",
        "|---------|------------|---------|----------------|\n",
        "| **Algebra** | `x = a + 1` | \"x equals a plus 1\" | ✅ Yes |\n",
        "| **Python** | `x = a + 1` | \"assign a plus 1 to x\" | ❌ No |\n",
        "| **Elixir** | `x = a + 1` | \"x matches a plus 1\" | ✅ Yes |\n",
        "\n",
        "## Why This Matters\n",
        "\n",
        "**In Python, this fails:**\n",
        "```python\n",
        "6 = 5 + 1  # SyntaxError: can't assign to literal\n",
        "```\n",
        "\n",
        "**In Elixir, this works:**\n",
        "```elixir\n",
        "6 = 5 + 1  # Success: 6 matches 5 + 1\n",
        "```\n",
        "\n",
        "**The insight**: Elixir's `=` is **bidirectional equality** (like math), not **unidirectional assignment** (like most programming languages).\n",
        "\n",
        "## Addressing a Common Question\n",
        "\n",
        "**Python Pro: \"But we still compute right-to-left, don't we?\"**\n",
        "\n",
        "You're absolutely right! In practice, we often do:\n",
        "\n",
        "```elixir\n",
        "x = 5 + 1  # We calculate 5 + 1 = 6, then bind x to 6\n",
        "```\n",
        "\n",
        "This looks just like assignment. **But the real magic becomes apparent when x is already bound - that's where Elixir becomes truly bidirectional:**\n",
        "\n",
        "### The Real Magic: Asserting Equality\n",
        "\n",
        "In Elixir, `^` Pin operator is used to refer to the existing value of variables - these variable are referred to as `already-bound`. \n",
        "\n",
        "**This works in Elixir (but fails in Python):**\n",
        "\n",
        "```elixir\n",
        "x = 6        # x is bound to 6 now\n",
        "6 = x        # Success! Assert \"6 equals x\"\n",
        "6 = 5 + 1    # Success! Assert \"6 equals 5 + 1\"\n",
        "\n",
        "# With pin operator for already-bound variables:\n",
        "\n",
        "a = 5\n",
        "^x = ^a + 1    # Assert \"a(5) + 1 equals x(6)\" ✓\n",
        "^a + 1 = ^x    # This also works ✓\n",
        "```\n",
        "\n",
        "**In Python:**\n",
        "\n",
        "```python\n",
        "x = 6\n",
        "6 = x        # SyntaxError: cannot assign to literal here. Maybe you meant '==' instead of '='?\n",
        "x = a + 1    # This will assign 6 to x and NOT match\n",
        "a + 1 = x    # SyntaxError: cannot assign to expression here. Maybe you meant '==' instead of '='?\n",
        "```\n",
        "\n",
        "### The Key Insight\n",
        "\n",
        "While computation often flows **right-to-left**, Elixir's `=` allows **bidirectional assertions** - you can assert equality in **any direction**, just like mathematical equations.\n",
        "\n",
        "**Joe's point**: The **capability** for bidirectional matching is what makes it algebraic, even when we don't always use it that way. It's the **potential** that matters.\n",
        "\n",
        "## Key Takeaway\n",
        "\n",
        "Stop thinking \"`=` means assign to\" and start thinking \"`=` means equals\" - just like in mathematics. While we often compute right-to-left, the ability to assert equality in any direction is what makes pattern matching fundamentally different from assignment.\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "ok - I enjoyed the detour on the meaning of `=` that I have forgotten over the years. Ok, what do we get by having this bidirectional equality in Elixir, that I don't get in python?\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Great question! The bidirectional equality gives you several powerful capabilities that Python doesn't have:\n",
        "\n",
        "**1. Data Validation**\n",
        "You can assert that your data has the expected structure and values:\n",
        "\n",
        "**Elixir:**\n",
        "```elixir\n",
        "# Ensure a function returns exactly what you expect\n",
        "{:ok, result} = some_function()  # # Crashes if not {:ok, value} for example, if function returns {:error, reason}\n",
        "```\n",
        "\n",
        "In Python, you'd need explicit if-statements to check this.\n",
        "\n",
        "**Python:**\n",
        "```python\n",
        "result = some_function()\n",
        "if result[0] != \"ok\":\n",
        "    raise ValueError(\"Expected success tuple\")\n",
        "actual_result = result[1]\n",
        "```\n",
        "\n",
        "**2. Destructuring with Constraints**\n",
        "You can extract values while simultaneously validating them:\n",
        "\n",
        "**Elixir:**\n",
        "```elixir\n",
        "# Extract coordinates, but only if z is exactly 0\n",
        "{x, y, 0} = get_coordinates()  # Crashes if z ≠ 0\n",
        "```\n",
        "\n",
        "**Python:**\n",
        "```python\n",
        "coords = get_coordinates()\n",
        "x, y, z = coords\n",
        "if z != 0:\n",
        "    raise ValueError(\"Expected z to be 0\")\n",
        "```\n",
        "\n",
        "So, this results in lot less code compared to Python and much easier to understand as the error-handling is delegated to Elixir - we work with the matches and if there is no match, Elixir will raise an error. \n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "that is nice - for the first time, I am hearing something concrete from you - I have read a lot of material on pattern matching, but never really understood that the essence here is the bidirectional equality and the joy it gives by enabling us to write concise code. \n",
        "\n",
        "So, what else should I know about pattern matching?\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Excellent! I'm glad that clicked for you. Let's explore a few more powerful pattern matching features:\n",
        "\n",
        "## Partial Matching with the \"Don't Care\" Variable\n",
        "\n",
        "Sometimes you only care about some parts of the data:\n",
        "\n",
        "**Elixir:**\n",
        "```elixir\n",
        "[first, _, third] = [\"apple\", \"banana\", \"cherry\"]\n",
        "# first = \"apple\", third = \"cherry\"\n",
        "# The underscore _ means \"I don't care about this value\"\n",
        "```\n",
        "\n",
        "Try this in iex and see what happens. What do you think `_` will be bound to?\n",
        "\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "When I try to print `_` in python, it prints `banana`. But Elixir got angry with me and gave me severe warnings to behave properly!\n",
        "```\n",
        "iex(35)> [first, _, third] = [\"apple\", \"banana\", \"cherry\"]\n",
        "[\"apple\", \"banana\", \"cherry\"]\n",
        "iex(36)> _\n",
        "error: invalid use of _. _ can only be used inside patterns to ignore values and cannot be used in expressions. Make sure you are inside a pattern or change it accordingly\n",
        "└─ iex:36\n",
        "\n",
        "** (CompileError) cannot compile code (errors have been logged)\n",
        "```\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Perfect observation! You've discovered an important difference between Python and Elixir.\n",
        "\n",
        "In **Python**, `_` is just a regular variable name (by convention used for \"throwaway\" values), so it gets the value \"banana\" and you can print it.\n",
        "\n",
        "In **Elixir**, `_` is a special language construct that means \"match anything but don't bind it to a variable.\" It's not a variable you can reference later - it's truly a \"don't care\" placeholder.\n",
        "\n",
        "This is Elixir being more explicit again! If you don't care about a value, you really can't access it later. This prevents bugs where you accidentally use a value you intended to ignore.\n",
        "\n",
        "If you want to ignore a value but still be able to reference it, you can use a named variable starting with underscore:\n",
        "\n",
        "```elixir\n",
        "[first, _middle, third] = [\"apple\", \"banana\", \"cherry\"]\n",
        "_middle  # This works - returns \"banana\"\n",
        "```\n",
        "\n",
        "Try this and see what happens. Elixir will give you a warning but still work.\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "Yes - true to what you said, Elixir politely informed me about the mismatch between my intention and then actual code, but it still printed banana\n",
        "```\n",
        "iex(37)> _middle  # This works - returns \"banana\"\n",
        "warning: the underscored variable \"_middle\" is used after being set. A leading underscore indicates that the value of the variable should be ignored. If this is intended please rename the variable to remove the underscore\n",
        "└─ iex:37\n",
        "\n",
        "\"banana\"\n",
        "```\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "That is great. Now let us look at another oft-used pattern. \n",
        "  \n",
        "\n",
        "## Head and Tail Matching\n",
        "\n",
        "In python, if you want to extract a list into 2 parts - head variable containing the first element and the tail variable containing a list with the rest of the elements, the unpacking operator `*` is handy. \n",
        "\n",
        "**Python:**\n",
        "\n",
        "```python\n",
        "\n",
        "head, *tail = [1, 2, 3, 4]\n",
        "# head = 1, tail = [2, 3, 4]\n",
        "```\n",
        "\n",
        "The same idea works, but the syntax is a bit different - pay attention to the space around `|` - this symbol is not attached to the tail variable in Elixir as `*` symbol was attached in python. \n",
        "\n",
        "**Elixir:**\n",
        "\n",
        "```elixir\n",
        "\n",
        "[head | tail] = [1, 2, 3, 4]\n",
        "\n",
        "# head = 1, tail = [2, 3, 4]\n",
        "\n",
        "```\n",
        "\n",
        "The corner cases work exactly like python - First try these statements in python and see what you get. Then translate these 2 python statements into Elixir syntax (remember Elixir is explicit) and see whether the behaviour is similar. \n",
        "  \n",
        "```python\n",
        "head, *tail = [1, 2] # would tail be a list in python and in elixir? \n",
        "\n",
        "head, *tail = [1] # what would tail be in python and in elixir?\n",
        "\n",
        "head, *tail = [] # would this work in python and in elixir?\n",
        "\n",
        "```\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "Yes I tried those 3 statements one by one in ipython and here is what I got:\n",
        "\n",
        "```\n",
        "In [15]: head, *tail = [1, 2] \n",
        "\n",
        "In [16]: head\n",
        "Out[16]: 1\n",
        "\n",
        "In [17]: tail\n",
        "Out[17]: [2]\n",
        "\n",
        "In [18]: head, *tail = [1] \n",
        "\n",
        "In [19]: head\n",
        "Out[19]: 1\n",
        "\n",
        "In [20]: tail\n",
        "Out[20]: []\n",
        "\n",
        "In [21]: head, *tail = [] \n",
        "---------------------------------------------------------------------------\n",
        "ValueError                                Traceback (most recent call last)\n",
        "Cell In[21], line 1\n",
        "----> 1 head, *tail = [] \n",
        "\n",
        "ValueError: not enough values to unpack (expected at least 1, got 0)\n",
        "```\n",
        "\n",
        "Then I translated them into Elixir and I got a similar behaviour. \n",
        "\n",
        "```\n",
        "iex(39)> [ head | tail ] = [1, 2]\n",
        "[1, 2]\n",
        "iex(40)> head\n",
        "1\n",
        "iex(41)> tail\n",
        "[2]\n",
        "iex(42)> [ head | tail ] = [1]\n",
        "[1]\n",
        "iex(43)> head\n",
        "1\n",
        "iex(44)> tail\n",
        "[]\n",
        "iex(45)> [ head | tail ] = []\n",
        "** (MatchError) no match of right hand side value: []\n",
        "    (stdlib 6.2.2) erl_eval.erl:667: :erl_eval.expr/6\n",
        "    iex:45: (file)\n",
        "```\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Excellent! You've discovered that Python and Elixir handle head/tail decomposition very similarly:\n",
        "\n",
        "✅ Both extract the first element as `head`  \n",
        "✅ Both put remaining elements in `tail` as a list (even if empty)  \n",
        "✅ Both fail when trying to extract from an empty list  \n",
        "\n",
        "The key difference is in error handling:\n",
        "- **Python**: Raises `ValueError` with a descriptive message\n",
        "- **Elixir**: Raises `MatchError` - pattern matching failed\n",
        "\n",
        "This head/tail pattern is extremely common in functional programming. You'll see `[head | tail]` everywhere in Elixir code for processing lists recursively.\n",
        "\n",
        "## Multiple Elements\n",
        "\n",
        "You can also extract multiple elements from the head:\n",
        "\n",
        "```elixir\n",
        "[first, second | rest] = [1, 2, 3, 4, 5]\n",
        "# first = 1, second = 2, rest = [3, 4, 5]\n",
        "```\n",
        "\n",
        "Try this and see what happens when you have exactly 2 elements: `[first, second | rest] = [1, 2]`\n",
        "\n",
        "What do you think `rest` will be?\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "As expected `rest` is an empty list. \n",
        "\n",
        "I love the flexibility of star operator in python - can we do something like this in Elixir?\n",
        "```python\n",
        "*first, last = [1, 2, 3, 4] # I want the tail alone and the rest in a list\n",
        "first, *middle, last = [1, 2, 3, 4] # I want the first and last alone and the rest in a list\n",
        "```\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Great question! Unfortunately, Elixir's `|` operator is more limited than Python's `*` operator. \n",
        "\n",
        "In Elixir, you can **only** use `|` to separate the **beginning** of a list from the **rest**. You cannot:\n",
        "- Extract from the end: `*first, last` ❌\n",
        "- Extract from the middle: `first, *middle, last` ❌\n",
        "\n",
        "So these Python patterns don't have direct Elixir equivalents:\n",
        "\n",
        "**Python (works):**\n",
        "```python\n",
        "*first, last = [1, 2, 3, 4]        # first=[1,2,3], last=4\n",
        "first, *middle, last = [1, 2, 3, 4] # first=1, middle=[2,3], last=4\n",
        "```\n",
        "\n",
        "**Elixir (doesn't work):**\n",
        "```elixir\n",
        "[first | last] = [1, 2, 3, 4]      # This is head|tail, not *first,last\n",
        "[first, middle | last] = [1, 2, 3, 4] # This is NOT first,*middle,last\n",
        "```\n",
        "\n",
        "In Elixir, you'd need to use other functions like `List.last/1` or `Enum.take/2` for these patterns. But the good news is that the head|tail pattern `[head | tail]` covers most common use cases in functional programming.\n",
        "\n",
        "This is one area where Python's unpacking is more flexible than Elixir's pattern matching.\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "Haha. You have finally hit upon a place where Elixir is less powerful than Python. Tell me more - you were always bragging about Elixir's superiority. Now I guess, you will make up some valid-sounding reason for why extracting the first part or the middle part is NOT that imporant.\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Haha, you caught me! You're absolutely right - I have been highlighting Elixir's strengths, and now you've found a legitimate area where Python is more flexible.\n",
        "\n",
        "I could try to rationalize this by saying \"functional programming typically processes lists from head to tail, so you rarely need to extract from the end...\" but that would be exactly the kind of excuse-making you're calling out! 😄\n",
        "\n",
        "The honest truth is: **Python's unpacking is more powerful and flexible than Elixir's pattern matching for lists.** Period.\n",
        "\n",
        "Elixir's `[head | tail]` pattern is optimized for the most common functional programming use case (recursive list processing), but it's definitely more limited than Python's `*` operator.\n",
        "\n",
        "This is a good reminder that no language is perfect at everything. Elixir makes trade-offs - it gains other powerful pattern matching features (like matching on data structure shapes, which we haven't covered yet), but loses some of Python's unpacking flexibility.\n",
        "\n",
        "You've discovered an important principle: always question the hype around any technology. Every language has strengths and weaknesses, and it's good to keep a critical eye!\n",
        "\n",
        "So what do you think - should we explore some areas where Elixir's pattern matching *is* more powerful than Python, or do you want to keep poking holes in my Elixir enthusiasm? 😉\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "It is OK - I just want to poke you once to bring you to terra firma (as you were in cloud nine all the time about Elixir). Anyway, I am excited about Elixir as well, so - no more poking at you. Are we done with pattern matching - if yes, please summarise what we have covered? if not, tell me what we are missing.\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Fair enough! You've successfully brought me back to earth. 😄\n",
        "\n",
        "We've covered the **core fundamentals** of pattern matching that you'll use 80% of the time:\n",
        "\n",
        "## What We've Covered ✅\n",
        "\n",
        "**1. Basic Concepts**\n",
        "- `=` as match operator (bidirectional equality)\n",
        "- Pattern matching vs assignment\n",
        "- Explicit structure matching: `[a, b, c] = list`\n",
        "\n",
        "**2. Practical Patterns**\n",
        "- Variables: `x = 5`\n",
        "- Lists: `[first, second, third] = list`\n",
        "- Ignoring values: `[first, _, third] = list`\n",
        "- Head/tail: `[head | tail] = list`\n",
        "- Multiple head elements: `[first, second | rest] = list`\n",
        "- **Pin operator** `^` for matching existing variables\n",
        "\n",
        "**3. Key Benefits**\n",
        "- Data validation (crashes on mismatch)\n",
        "- Concise destructuring with constraints\n",
        "- Less error-checking code needed\n",
        "\n",
        "## What We Haven't Covered (Advanced Topics)\n",
        "\n",
        "- Pattern matching on **tuples** and **maps** (Elixir's key-value structures)\n",
        "- **Guards** (adding conditions to patterns)\n",
        "- Pattern matching in **function definitions**\n",
        "\n",
        "\n",
        "But honestly? What we've covered gives you the foundation for 80% of pattern matching use cases. The advanced topics can wait until you're more comfortable with Elixir.\n",
        "\n",
        "Ready to move on to our second core concept: **immutability**?\n",
        "\n",
        "## Immutability\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "yes my dear Elixir mentor.\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Excellent! Let's dive into **immutability** - another core concept that makes Elixir different from Python.\n",
        "\n",
        "## Quick Question First\n",
        "\n",
        "In Python, what happens when you do this:\n",
        "\n",
        "```python\n",
        "numbers = [1, 2, 3]\n",
        "numbers.append(4)\n",
        "print(numbers)  # What gets printed?\n",
        "```\n",
        "\n",
        "And what happens to any other variables that were pointing to the same list?\n",
        "\n",
        "```python\n",
        "backup = numbers\n",
        "numbers.append(5)\n",
        "print(backup)  # What gets printed here?\n",
        "```\n",
        "\n",
        "Try this in Python first, then tell me what you observe. This will help us understand why immutability matters.\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "backup is also modified to [1, 2, 3, 4, 5]. And that is expected as lists are references in python like arrays are pointers in C and C++. \n",
        "So, no big deal.\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Exactly! You understand the issue perfectly. In Python, `backup` and `numbers` point to the same list object in memory, so modifying one affects the other.\n",
        "\n",
        "This can lead to subtle bugs:\n",
        "\n",
        "```python\n",
        "def process_data(data_list):\n",
        "    data_list.append(\"processed\")  # Oops! Modified the original\n",
        "    return data_list\n",
        "\n",
        "original = [1, 2, 3]\n",
        "result = process_data(original)\n",
        "print(original)  # [1, 2, 3, \"processed\"] - Surprise!\n",
        "```\n",
        "\n",
        "## Elixir's Solution: Everything is Immutable\n",
        "\n",
        "In Elixir, you **cannot** modify existing data. Period.\n",
        "\n",
        "Try this in iex:\n",
        "\n",
        "```elixir\n",
        "numbers = [1, 2, 3]\n",
        "```\n",
        "\n",
        "Now, how would you \"add\" 4 to this list? There's no `append` method. Try typing `numbers.` and see what tab completion suggests (if any).\n",
        "\n",
        "What do you think happens when you try to \"modify\" a list in Elixir?\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "when I press tab after typing `numbers.` i don't seem to get anything, may be tab completion is not working\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "That's actually the point! There are no methods on the list itself because lists are immutable - you can't modify them directly.\n",
        "\n",
        "Instead, Elixir provides functions that create **new** lists based on existing ones. Try this:\n",
        "\n",
        "```elixir\n",
        "numbers = [1, 2, 3]\n",
        "new_numbers = [4 | numbers]\n",
        "```\n",
        "\n",
        "What do you get? And then check what `numbers` contains - has it changed?\n",
        "\n",
        "Alternatively, you can try:\n",
        "```elixir\n",
        "new_numbers = numbers ++ [5]\n",
        "```\n",
        "\n",
        "The key insight: Instead of modifying existing data, Elixir creates new data structures. This means `numbers` will always contain `[1, 2, 3]` no matter what you do with `new_numbers`.\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "Here is what I got, when I tried your suggestion, but there is something curious in the output of `++` operator. It shows that tail operator `|`, rather than comma to separate the new element whereas the comma is used when I used the tail operator `|` - is Elixir playing it funny? \n",
        "\n",
        "```\n",
        "iex(49)> new_numbers = [4 | numbers]\n",
        "[4, 1, 2, 3]\n",
        "iex(50)> numbers\n",
        "[1, 2, 3]\n",
        "iex(51)> new_numbers = numbers ++ 5\n",
        "[1, 2, 3 | 5]\n",
        "iex(52)> new_numbers\n",
        "[1, 2, 3 | 5]\n",
        "iex(53)> numbers\n",
        "[1, 2, 3]\n",
        "```\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Great observation! You've discovered something important about how Elixir displays lists.\n",
        "\n",
        "The issue is with this line:\n",
        "```elixir\n",
        "new_numbers = numbers ++ 5\n",
        "```\n",
        "\n",
        "The `++` operator expects **two lists**, but you gave it a list and a number. So Elixir created what's called an \"improper list\" - a list that doesn't end with an empty list `[]`.\n",
        "\n",
        "That's why it displays as `[1, 2, 3 | 5]` - Elixir is showing you the internal structure where the tail is `5` (a number) instead of `[]` (empty list).\n",
        "\n",
        "Try this instead:\n",
        "```elixir\n",
        "new_numbers = numbers ++ [5]\n",
        "```\n",
        "\n",
        "Notice the square brackets around `5`? Now you're concatenating two proper lists: `[1, 2, 3]` and `[5]`.\n",
        "\n",
        "**Summary of list operations:**\n",
        "- `[new_element | existing_list]` - prepends to front\n",
        "- `existing_list ++ [new_element]` - appends to end  \n",
        "- `existing_list ++ other_list` - concatenates two lists\n",
        "\n",
        "Try the corrected version and see how it displays now!\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "Yes that looks good now.\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Perfect! Now you see the difference:\n",
        "\n",
        "- `numbers ++ [5]` creates `[1, 2, 3, 5]` (proper list)\n",
        "- `numbers ++ 5` created `[1, 2, 3 | 5]` (improper list)\n",
        "\n",
        "## The Key Point About Immutability\n",
        "\n",
        "Notice that in all these operations, the original `numbers` list never changed. It's still `[1, 2, 3]`. This is **immutability** in action.\n",
        "\n",
        "**Benefits:**\n",
        "1. **No surprise mutations** - `numbers` will always be `[1, 2, 3]`\n",
        "2. **Safe sharing** - You can pass `numbers` to any function without worrying it will be modified\n",
        "3. **Easier debugging** - Data doesn't change unexpectedly\n",
        "\n",
        "**The trade-off:**\n",
        "- Creating new data structures uses more memory (but Elixir optimizes this behind the scenes)\n",
        "\n",
        "Let's test your understanding: If you have a function that needs to \"modify\" a list, what does it actually do in Elixir? And how would you use the result?\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "I guess, it would make a copy first, then do the modification and return the copy. \n",
        "I think this idea of making a copy first and using that to modify is used by Pandas quite heavily as we could chain multiple operations on a dataframe. Am I right?\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "You're thinking in the right direction, but there's a subtle difference!\n",
        "\n",
        "**Pandas approach**: Makes copies and allows method chaining\n",
        "```python\n",
        "df.dropna().fillna(0).groupby('column').sum()  # Each method returns a new DataFrame\n",
        "```\n",
        "\n",
        "**Elixir approach**: Functions return new data structures, but you need to explicitly capture the result\n",
        "\n",
        "In Elixir, functions don't modify - they **transform**. So if you want to apply multiple transformations, you'd do:\n",
        "\n",
        "```elixir\n",
        "# Step by step\n",
        "numbers = [1, 2, 3]\n",
        "step1 = [0 | numbers]        # [0, 1, 2, 3]\n",
        "step2 = step1 ++ [4]         # [0, 1, 2, 3, 4]\n",
        "final = [99 | step2]         # [99, 0, 1, 2, 3, 4]\n",
        "```\n",
        "\n",
        "But this gets verbose. That's where our third core concept comes in: **piping**! It lets you chain operations elegantly, just like Pandas.\n",
        "\n",
        "We'll cover that next, but first - try creating a list that starts with `[1, 2, 3]`, adds `4` to the end, then adds `0` to the beginning. What do you get?\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "I got [0, 1, 2, 3, 4].\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Perfect! You successfully chained the operations:\n",
        "\n",
        "1. Started with `[1, 2, 3]`\n",
        "2. Added `4` to the end: `[1, 2, 3, 4]`  \n",
        "3. Added `0` to the beginning: `[0, 1, 2, 3, 4]`\n",
        "\n",
        "Now you can see how immutability works in practice - each step created a new list without modifying the previous ones.\n",
        "\n",
        "## Quick Summary: Immutability\n",
        "\n",
        "✅ **No mutations** - data never changes after creation  \n",
        "✅ **Safe sharing** - no surprise side effects  \n",
        "✅ **Functions transform** - they return new data instead of modifying existing data  \n",
        "\n",
        "The downside is that chaining operations can get verbose with intermediate variables. But that's exactly what our third concept solves!\n",
        "\n",
        "Ready to learn about **piping** - Elixir's elegant solution for chaining operations?\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "But before we start piping, tell me how Elixir manages this whole mess of all the variables left behind by each operation and the ton of memory it would consume?\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Excellent question! This is a crucial concern when moving from mutable to immutable languages.\n",
        "\n",
        "## Elixir's Memory Magic\n",
        "\n",
        "**1. Structural Sharing**\n",
        "Elixir doesn't actually copy the entire data structure. It shares unchanged parts:\n",
        "\n",
        "```elixir\n",
        "original = [1, 2, 3]\n",
        "new_list = [0 | original]  # [0, 1, 2, 3]\n",
        "```\n",
        "\n",
        "Behind the scenes:\n",
        "- `new_list` creates a new \"head\" node pointing to `0`\n",
        "- The tail points to the **same memory** as `original`\n",
        "- Only the new head node uses extra memory!\n",
        "\n",
        "**2. Garbage Collection**\n",
        "When variables go out of scope, Elixir's garbage collector automatically reclaims unused memory:\n",
        "\n",
        "```elixir\n",
        "def process_data() do\n",
        "  step1 = [1, 2, 3]\n",
        "  step2 = [0 | step1]     # step1 might be collected if not used elsewhere\n",
        "  step3 = step2 ++ [4]    # step2 might be collected\n",
        "  step3                   # Only step3 survives\n",
        "end\n",
        "```\n",
        "\n",
        "**3. BEAM VM Optimizations**\n",
        "The Erlang VM (BEAM) that runs Elixir has decades of optimization for exactly this pattern.\n",
        "\n",
        "**The Result**: In practice, immutable operations in Elixir are surprisingly memory-efficient and often faster than you'd expect!\n",
        "\n",
        "This is why functional languages can be both safe AND performant.\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "Ok we have covered 2 topics - pattern matching and immutability. Please summarise both and tell me what is next.\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "## Summary So Far\n",
        "\n",
        "**1. Pattern Matching** ✅\n",
        "- `=` is match operator (bidirectional equality), not assignment\n",
        "- Explicit structure: `[a, b, c] = list`\n",
        "- Head/tail decomposition: `[head | tail] = list`\n",
        "- Data validation: crashes on mismatch\n",
        "- Benefits: Concise code, built-in validation\n",
        "\n",
        "**2. Immutability** ✅\n",
        "- No mutations - data never changes after creation\n",
        "- Functions return new data instead of modifying existing\n",
        "- Safe sharing - no surprise side effects\n",
        "- Memory efficient through structural sharing and garbage collection\n",
        "\n",
        "Before we look at piping, I want you to look at how loops are handled in Elixir. Just to get you a bit excited! - there is no traditional for loop in Elixir :). Have you heard of that? \n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "Hmm. That is wild - I thought that conditionals and looping are the bread and butter of programming.\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "You're absolutely right - conditionals and looping ARE fundamental! But Elixir takes a different approach to looping that's actually more powerful once you get used to it.\n",
        "\n",
        "Instead of traditional `for` loops, Elixir uses **functions that operate on collections**. Let me show you with a familiar example:\n",
        "\n",
        "**Python:**\n",
        "```python\n",
        "numbers = [1, 2, 3, 4]\n",
        "for num in numbers:\n",
        "    print(num * 2)\n",
        "```\n",
        "\n",
        "**Elixir equivalent:**\n",
        "```elixir\n",
        "numbers = [1, 2, 3, 4]\n",
        "Enum.each(numbers, fn num -> IO.puts(num * 2) end)\n",
        "```\n",
        "\n",
        "But this Elixir code introduces two new concepts we have not yet covered:\n",
        "1. Enum module and its utility functions for working with collections like lists, tuples, etc.\n",
        "2. Anonymous functions\n",
        "\n",
        "But before we cover these 2 new ideas, let us take a Detour to really understand the different paradigms that are available in python to do a simple loop to print the values in a list, one by one. \n",
        "\n",
        "## Detour - Different paradigms to loop over a list\n",
        "\n",
        "When working with collections, **looping over items (iteration)** is one of the most common operations. You constantly need to:\n",
        "- Process each item (validate, transform, display)\n",
        "- Find specific items (search, filter)\n",
        "- Aggregate data (sum, count, analyze)\n",
        "\n",
        "Python's approach to iteration has evolved significantly, inheriting ideas from different programming paradigms:\n",
        "\n",
        "## Evolution of Python's Iteration Mental Models\n",
        "\n",
        "**1. C-Style Indexing (Inherited from Traditional Languages)**\n",
        "```python\n",
        "fruits = [\"apple\", \"banana\", \"cherry\"]\n",
        "for i in range(len(fruits)):\n",
        "    print(f\"{i}: {fruits[i]}\")\n",
        "```\n",
        "**Mental Model:** \"Manually control the counter, access by index\"  \n",
        "**From:** C, Java, early programming languages  \n",
        "**Advantages:** Explicit control, familiar to C programmers  \n",
        "**Drawbacks:** Verbose, managing index bounds manually can sometimes lead to hard-to-find bugs\n",
        "\n",
        "---\n",
        "\n",
        "**2. Direct Iteration (Idiomatic Python Looping)**\n",
        "```python\n",
        "for fruit in fruits:\n",
        "    print(fruit)  # But we lost the index!\n",
        "```\n",
        "**Mental Model:** \"Iterate over objects directly, not indices\"  \n",
        "**From:** Python's object-oriented nature, iterator protocol  \n",
        "**Advantages:** Cleaner, safer, more Pythonic  \n",
        "**Drawbacks:** Lost access to index when needed\n",
        "\n",
        "---\n",
        "\n",
        "**3. Enumerate (Pythonic Best Practice)**\n",
        "```python\n",
        "for index, fruit in enumerate(fruits):\n",
        "    print(f\"{index}: {fruit}\")\n",
        "```\n",
        "**Mental Model:** \"Get both item and position naturally\"  \n",
        "**From:** Python's tuple unpacking + built-in functions  \n",
        "**Advantages:** Clean syntax, provides both index and value when needed, Pythonic, no manual index management, works with any iterable  \n",
        "**Drawbacks:** Still allows side effects inside the loop, can modify external state, potential for bugs when loop body becomes complex\n",
        "\n",
        "---\n",
        "\n",
        "**4. Functional Style (Borrowed from Functional Programming)**\n",
        "```python\n",
        "print_fruit = lambda x: print(f\"{x[0]}: {x[1]}\")\n",
        "list(map(print_fruit, enumerate(fruits)))\n",
        "```\n",
        "**Mental Model:** \"Transform data, then apply functions\"  \n",
        "**From:** Functional programming languages (Lisp, Haskell)  \n",
        "**Advantages:** Separates data transformation from processing, encourages pure functions, more composable, easier to reason about data flow  \n",
        "**Drawbacks:** Less readable for Python developers unfamiliar with functional style, `list(map(...))` is verbose, lambda syntax can be cryptic for complex operations\n",
        "\n",
        "Each evolution solved real problems while building on Python's growing capabilities. Notice how Python gradually moved from \"manual control\" to \"declarative intent.\"\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "I really like this detour. I am able to see how Python allows for all these different possibilities. How does Elixir compare? Does it only allow me to do `4. Functional style` only? \n",
        "\n",
        "The challenge I have with this kind of a functional code is that people write even the lambda inside map - hence it results in lot of mental gymnastics to really understand what is going on and where the brackets for each operation start and stop. \n",
        "\n",
        "And even though generators are great from a conceptual idea perspective, they make it to hard to work in a REPL environment doing interactive coding as I have to often call list to see the results. I wish there is a better way in Python - how are these challenges tackled in Elixir?\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Excellent observations! You've hit on some real pain points with functional programming in Python. Elixir addresses these challenges elegantly:\n",
        "\n",
        "Let me use the exact same example listed under `4. Functional Style` to show how Elixir solves both challenges:\n",
        "\n",
        "## Challenge 1: Bracket Hell and Mental Gymnastics\n",
        "\n",
        "**Python (hard to read - nested brackets):**\n",
        "```python\n",
        "fruits = [\"apple\", \"banana\", \"cherry\"]\n",
        "list(map(lambda x: print(f\"{x[0]}: {x[1]}\"), enumerate(fruits)))\n",
        "```\n",
        "\n",
        "**Elixir (reads left to right):**\n",
        "```elixir\n",
        "fruits = [\"apple\", \"banana\", \"cherry\"]\n",
        "\n",
        "fruits\n",
        "|> Enum.with_index()                    # Like enumerate() \n",
        "|> Enum.each(fn {fruit, index} ->       # fn is like lambda - indicates an anonymous function, but it can span multiple lines\n",
        "     IO.puts(\"#{index}: #{fruit}\") \n",
        "   end)\n",
        "```\n",
        "\n",
        "Don't worry about each step now - just get an overall idea of how readable the piping syntax is compared to the bracket syntax. We will cover the Enum utility functions as well as anonymous functions. \n",
        "\n",
        "No nested brackets! You read from top to bottom: \"Take fruits, add indices, then print each one.\"\n",
        "\n",
        "## Challenge 2: REPL Unfriendly (No `list()` Wrapper Needed)\n",
        "\n",
        "**Python (need list() to see results):**\n",
        "```python\n",
        "result = map(lambda x: print(f\"{x[0]}: {x[1]}\"), enumerate(fruits))  # generator prints memory address :)\n",
        "list(result)  # Actually see the output\n",
        "```\n",
        "\n",
        "**Elixir (immediate results in iex):**\n",
        "\n",
        "```elixir\n",
        "fruits\n",
        "|> Enum.with_index()     # Returns actual list immediately: [{\"apple\", 0}, {\"banana\", 1}, {\"cherry\", 2}]\n",
        "```\n",
        "\n",
        "Please don't try to execute these examples yet in iex - I just want to give you an idea of how the different mental models for looping in Python compares to the single model in Elixir. Though I told you that there is no For loop, there is actually a for construct in Elixir, but we will tuck it away for now and come back to it once the timing for it is perfect. \n",
        "\n",
        "So, how do you feel about the functional style in Elixir? \n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "Not having to do the list conversion each time is a great timesaver for me. But I really like the following simple idiomatic python way of going through each item inside a for loop. \n",
        "\n",
        "```python\n",
        "for fruit in fruits:\n",
        "    print(fruit)\n",
        "```\n",
        "\n",
        "To me, the idiomatic python code is so easy-to-read compared to the functional alternative. Why is this not supported in Elixir? Is that not functional? Why do I have to do this map thing. That always seems a little bit counterintuitive to me.\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "You're absolutely right! That idiomatic Python for loop is beautifully readable and intuitive. Your frustration is completely valid! - See I also came from Python to Elixir. So I still love certain aspects of Python :)\n",
        "\n",
        "The reason goes back to **immutability**. Traditional for loops are designed around **mutation**:\n",
        "\n",
        "### The Real Problem: Side Effects and Shared State\n",
        "\n",
        "\n",
        "\n",
        "**Python (mutation inside loop possible):**\n",
        "\n",
        "```python\n",
        "fruits = [\"apple\", \"banana\", \"cherry\"]\n",
        "\n",
        "for i, fruit in enumerate(fruits):\n",
        "\tfruits[i] = fruit.upper() # Mutating the original list!\n",
        "\n",
        "print(fruits) # ['APPLE', 'BANANA', 'CHERRY']\n",
        "\n",
        "```\n",
        "\n",
        "  \n",
        "**Why this is dangerous:**\n",
        "\n",
        "```python\n",
        "original_fruits = [\"apple\", \"banana\", \"cherry\"]\n",
        "backup_fruits = original_fruits # Both point to same list!\n",
        "\n",
        "for i, fruit in enumerate(original_fruits):\n",
        "\toriginal_fruits[i] = fruit.upper() # Mutating original\n",
        "\n",
        "print(backup_fruits) # ['APPLE', 'BANANA', 'CHERRY'] - Surprise! Backup changed too\n",
        "\n",
        "```\n",
        " \n",
        "\n",
        "**Elixir prevents this entirely:**\n",
        "\n",
        "```elixir\n",
        "\n",
        "fruits = [\"apple\", \"banana\", \"cherry\"]\n",
        "\n",
        "# You literally CANNOT mutate fruits\n",
        "# No fruits[i] = new_value syntax exists\n",
        "\n",
        "# You must create a new list:\n",
        "uppercased_fruits = \n",
        "\tEnum.map(fruits, \n",
        "\t\tfn fruit -> String.upcase(fruit) end)\n",
        "\n",
        "# fruits is still [\"apple\", \"banana\", \"cherry\"]\n",
        "```\n",
        "  \n",
        "So the \"no for loop\" design forces you away from dangerous mutation patterns and toward safer transformation patterns.\n",
        "\n",
        "## 3 Core Functional Patterns\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "Ok. That is a simple yet very clear and concrete explanation of why mutation inside a for loop can be dangerous. So, tell me if I want to make the switch to thinking more functionally, what should I do?\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Great question! Here's a practical roadmap to shift your thinking from imperative to functional:\n",
        "\n",
        "## Mental Model Shift: From \"Do Things\" to \"Transform Things\"\n",
        "\n",
        "**Instead of thinking:** \"Loop through and modify each item\"  \n",
        "**Think:** \"Transform this collection into a new collection\"\n",
        "\n",
        "## The 3 Core Functional Patterns\n",
        "\n",
        "**1. Map** - Transform each item  \n",
        "*\"Make all fruits uppercase\"*\n",
        "\n",
        "**2. Filter** - Keep only some items  \n",
        "*\"Keep only fruits with more than 5 letters\"*\n",
        "\n",
        "**3. Reduce** - Combine all items into one result  \n",
        "*\"Count total letters in all fruits\"*\n",
        "\n",
        "That's it! Every loop you've ever written falls into one of these three patterns.\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "Wow - that is a very clear and concise way of thinking about it. \n",
        "\n",
        "Let us go through a few examples that illustrate the different types of operations we do, under each of these 3 core functional patterns - map, filter and reduce.\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Perfect! Let's go through concrete examples that show how common operations fit these patterns - Please skim the examples to get an overall ideas - we will work through each of these cases one by one and see how to translate them into Elixir.\n",
        "\n",
        "## 1. MAP - Transform Each Item\n",
        "\n",
        "**\"I want to change every item in some way\"**\n",
        "\n",
        "**Python examples:**\n",
        "```python\n",
        "# Make all uppercase\n",
        "[fruit.upper() for fruit in fruits]\n",
        "\n",
        "# Add tax to prices  \n",
        "[price * 1.08 for price in prices]\n",
        "\n",
        "# Get string lengths\n",
        "[len(word) for word in words]\n",
        "```\n",
        "\n",
        "**The pattern:** Input list → Same number of items → Different values\n",
        "\n",
        "## 2. FILTER - Keep Only Some Items\n",
        "\n",
        "**\"I want to keep only items that meet a condition\"**\n",
        "\n",
        "**Python examples:**\n",
        "```python\n",
        "# Only long words\n",
        "[word for word in words if len(word) > 5]\n",
        "\n",
        "# Only positive numbers\n",
        "[num for num in numbers if num > 0]\n",
        "\n",
        "# Only fruits starting with `a`\n",
        "[fruit for fruit in fruits if fruit.startswith(\"a\")]\n",
        "```\n",
        "\n",
        "**The pattern:** Input list → Fewer (or same) items → Same values\n",
        "\n",
        "## 3. REDUCE - Combine All Into One Result\n",
        "\n",
        "**\"I want to combine all items into a single answer\"**\n",
        "\n",
        "**Python examples:**\n",
        "```python\n",
        "# Sum all numbers\n",
        "sum(numbers)\n",
        "\n",
        "# Find maximum\n",
        "max(numbers)\n",
        "\n",
        "# Join into string\n",
        "\", \".join(fruits)\n",
        "```\n",
        "\n",
        "**The pattern:** Input list → Single result\n",
        "\n",
        "## Core Functional Pattern 1 - Map\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "Let us start with problem 1.1 under Map - Make all uppercase. \n",
        "\n",
        "```python\n",
        "fruits = [\"apple\", \"banana\", \"cherry\"]\n",
        "[fruit.upper() for fruit in fruits]\n",
        "# or the functional style\n",
        "list(map(lambda x: x.upper(), fruits))\n",
        "```\n",
        "\n",
        "How do I transform this into Elixir? Please do not give me the answer - if you have NOT covered all the ingredients to solve this problem, then explain them first. \n",
        "\n",
        "I would like to learn by trying it myself and going through the struggle before peeking at the solution - research proves that this is the best way to learn for the long-term as these struggles create hooks in our brain to receive the answers and remember them for the long-term - if I read through your solution, it might feel good in the short-term, but I am unlikely to remember it in the long-term.\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Excellent approach! You're absolutely right about learning through struggle - it creates much stronger memory pathways.\n",
        "\n",
        "You'll need three things we haven't covered yet:\n",
        "\n",
        "## Ingredient 1: Anonymous Functions\n",
        "\n",
        "In Python, you'd use a lambda. In Elixir, you use `fn`:\n",
        "\n",
        "**Python:**\n",
        "```python\n",
        "lambda x: x.upper()\n",
        "```\n",
        "\n",
        "**Elixir:**\n",
        "```elixir\n",
        "fn fruit -> String.upcase(fruit) end\n",
        "```\n",
        "\n",
        "The syntax is: `fn parameter -> body end`\n",
        "\n",
        "Though I have shown you a single line anonymous function, it is not a requirement in Elixir. I just want to keep things similar to reduce the mental burden on you. \n",
        "\n",
        "## Ingredient 2: The Enum Module\n",
        "\n",
        "Elixir's `Enum` module contains all the functions for working with collections (lists, etc.). It's like Python's built-in functions (`map`, `filter`) but organized in a module.\n",
        "\n",
        "Try this in iex to explore:\n",
        "```elixir\n",
        "h Enum\n",
        "```\n",
        "\n",
        "You'll see a lot of information - scroll up to find the starting point. \n",
        "\n",
        "Another way is to look up the same information in hexdocs:\n",
        "[Enum — Elixir v1.18.4](https://hexdocs.pm/elixir/Enum.html)\n",
        "\n",
        "Check this out and compare what you see in iex and at hexdocs - are they the same? hexdocs has a lot more information than iex. And did you notice that there is even a cheatsheet - for now, don't go there as the examples there use a map which we have not yet covered. \n",
        "\n",
        "So, you have 2 choices to lookup docs - for small and quick things, you can use iex, but for long ones like this, it is better to use a browser. You can also use `Cmd/Ctrl-K` to search for items quickly. \n",
        "\n",
        "To figure out what function in Enum to use, search for the first pattern name - `map` and see what you get. Also see the same docs in iex using `h Enum.map`. Don't worry about the spec and any other thing you don't understand - just focus on the examples and see whether you understand them. Copy and paste them into iex to understand how they work. \n",
        "\n",
        "## Ingredient 3: String Functions\n",
        "\n",
        "The last piece of the puzzle is to figure out a function to transform from lowercase to uppercase. Lookup docs `String.upcase` function in iex using `h String.upcase`. \n",
        "\n",
        "Now try to piece these together! You have:\n",
        "- A list: `[\"apple\", \"banana\", \"cherry\"]`\n",
        "- An Enum function that transforms each element\n",
        "- An anonymous function that uppercases a string\n",
        "\n",
        "And here is the code you have translate:\n",
        "```python\n",
        "fruits = [\"apple\", \"banana\", \"cherry\"]\n",
        "list(map(lambda x: x.upper(), fruits))\n",
        "```\n",
        "\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "yes I got it working\n",
        "\n",
        "```elixir\n",
        "fruits = [\"apple\", \"banana\", \"cherry\"]\n",
        "Enum.map(fruits, fn x -> String.upcase(x) end)\n",
        "```\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Excellent work! You successfully pieced together all three ingredients:\n",
        "\n",
        "✅ `Enum.map` for transforming each element  \n",
        "✅ Anonymous function `fn x -> String.upcase(x) end`  \n",
        "✅ `String.upcase` for the transformation  \n",
        "\n",
        "Your Elixir code is a direct translation of the Python functional style:\n",
        "\n",
        "**Python:**\n",
        "```python\n",
        "list(map(lambda x: x.upper(), fruits))\n",
        "```\n",
        "\n",
        "**Your Elixir:**\n",
        "```elixir\n",
        "Enum.map(fruits, fn x -> String.upcase(x) end)\n",
        "```\n",
        "\n",
        "Notice how similar they are! The main differences:\n",
        "- `list(map(...))` becomes `Enum.map(...)`\n",
        "- `lambda x:` becomes `fn x ->`\n",
        "- `x.upper()` becomes `String.upcase(x)`\n",
        "- `end` instead of just closing parentheses\n",
        "\n",
        "Now let's see if you can tackle the next one. Here's problem 1.2:\n",
        "\n",
        "**Python:**\n",
        "```python\n",
        "prices = [10.0, 25.50, 8.75]\n",
        "# intentionally I am NOT giving you the functional equivalent in python to help you flex your mental muscles :)\n",
        "[price * 1.08 for price in prices]  # Add 8% tax\n",
        "```\n",
        "\n",
        "Try translating this to Elixir. You already have all the ingredients you need!\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "yes I got it.\n",
        "\n",
        "```elixir\n",
        "prices = [10.0, 25.50, 8.75]\n",
        "Enum.map(prices, fn x -> x * 1.08 end)\n",
        "```\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Perfect! You've got the pattern down. Notice how the anonymous function `fn x -> x * 1.08 end` directly mirrors the Python lambda logic.\n",
        "\n",
        "You're seeing that once you understand the basic structure of `Enum.map(collection, fn item -> transformation end)`, you can handle any transformation.\n",
        "\n",
        "Let's try one more map example before moving to filter. Here's problem 1.3:\n",
        "\n",
        "**Python:**\n",
        "```python\n",
        "words = [\"cat\", \"elephant\", \"dog\", \"butterfly\"]\n",
        "[len(word) for word in words]  # Get string lengths\n",
        "```\n",
        "\n",
        "This one requires you to find the right function to get string length. Try looking up string length functions in Elixir. \n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "I nailed this one too.\n",
        "\n",
        "```elixir\n",
        "words = [\"cat\", \"elephant\", \"dog\", \"butterfly\"]\n",
        "Enum.map(words, fn x -> String.length(x) end)\n",
        "```\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Fantastic! You're really getting the hang of this pattern. You correctly found `String.length/1` and applied it in the anonymous function.\n",
        "\n",
        "  \n",
        "\n",
        "You've now mastered the **MAP** pattern:\n",
        "\n",
        "- Transform each item in a collection\n",
        "\n",
        "- Get back the same number of items\n",
        "\n",
        "- Use `Enum.map(collection, fn item -> transformation end)`\n",
        "\n",
        "Before we move on to the next pattern FILTER, I want you to give you a few detour to help you understand a few things about Elixir - some of them are easy and some of them might feel strange at first - but you will see them in Phoenix often, so I want you to be fully prepared. \n",
        "\n",
        "## Detour - How Functions are Organized in Elixir vs Python\n",
        "\n",
        "The Problem: Converting a String to Uppercase\n",
        "\n",
        "Let's just return to the simple problem we handled in our first task -  to convert \"hello world\" to \"HELLO WORLD\". This simple task reveals a fundamental difference in how Python and Elixir organize code.\n",
        "\n",
        "## Python's Object-Oriented Approach\n",
        "\n",
        "```python\n",
        "text = \"hello world\"\n",
        "result = text.upper()\n",
        "print(result)  # \"HELLO WORLD\"\n",
        "```\n",
        "\n",
        "**How it works:**\n",
        "- The string `\"hello world\"` is an **object**\n",
        "- The `upper()` method **belongs to** the string object\n",
        "- We call the method **on** the object: `text.upper()`\n",
        "- Fortunately, the String function return a new string without modifying the original, just like the functional way, \n",
        "- but many python functions mutate the data held in the object e.g. list.append(\"no new lists please\")\n",
        "- The object transforms itself\n",
        "\n",
        "This is the **Object-Oriented way**: \"Hey string, uppercase yourself!\"\n",
        "\n",
        "## Elixir's Functional Approach\n",
        "\n",
        "```elixir\n",
        "text = \"hello world\"\n",
        "result = String.upcase(text)\n",
        "IO.puts(result)  # \"HELLO WORLD\"\n",
        "```\n",
        "\n",
        "**How it works:**\n",
        "- The string `\"hello world\"` is just **data**\n",
        "- The `upcase` function **belongs to** the `String` module\n",
        "- We pass the data **to** the function: `String.upcase(text)`\n",
        "- The function creates new data without changing the original\n",
        "\n",
        "This is the **Functional way**: \"Hey String module, create an uppercase version of this data!\"\n",
        "\n",
        "## The Mental Model Difference\n",
        "\n",
        "### **Python: Methods Belong to Objects**\n",
        "```python\n",
        "# Methods are attached to the data\n",
        "text = \"hello world\"\n",
        "text.upper()        # Method called ON the string\n",
        "text.split()        # Method called ON the string\n",
        "text.replace(\"l\", \"x\")\n",
        "\n",
        "numbers = [1, 2, 3]\n",
        "numbers.append(4)   # Method called ON the list\n",
        "```\n",
        "\n",
        "### **Elixir: Functions Belong to Modules**\n",
        "```elixir\n",
        "# Functions live in modules, data is passed TO them\n",
        "text = \"hello world\"\n",
        "String.upcase(text)           # Function takes string as argument\n",
        "String.split(text)            # Function takes string as argument  \n",
        "String.replace(text, \"l\", \"x\") # Function takes string as argument\n",
        "\n",
        "numbers = [1, 2, 3]\n",
        "List.insert_at(numbers, -1, 4) # Function takes list as argument\n",
        "```\n",
        "\n",
        "## Why This Difference Matters\n",
        "\n",
        "**Python's way**: Data carries behavior with it\n",
        "- `\"hello\".upper()` - the string knows how to uppercase itself\n",
        "- Each data type has its own methods\n",
        "\n",
        "**Elixir's way**: Behavior is separate from data\n",
        "- `String.upcase(\"hello\")` - the String module knows how to work with strings\n",
        "- Data is just data, functions transform it\n",
        "\n",
        "## Getting Help\n",
        "\n",
        "**Python**: Ask the object what it can do\n",
        "```python\n",
        "help(str)  # Shows string methods\n",
        "dir(\"hello\")   # Lists available methods for the string object \"hello\"\n",
        "```\n",
        "\n",
        "**Elixir**: Ask the module what functions it has\n",
        "```elixir\n",
        "h String.upcase    # Shows function documentation\n",
        "h String           # Shows all String module functions\n",
        "```\n",
        "\n",
        "This mental shift from \"objects with methods\" to \"modules with functions\" is fundamental to thinking functionally in Elixir.\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "Hmmm. That is interesting - but why did Elixir use `upcase` instead of `uppercase` - I searched for `upper` in hexdocs, but could not really figure out the function and I had to go through the entire list of functions to find it. Why change something that is well-established?\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Great question! This is actually a common frustration when switching between languages. The naming differences come from Elixir's heritage and design philosophy:\n",
        "\n",
        "## The Heritage Factor\n",
        "\n",
        "Elixir is built on **Erlang**, which has been around since the 1980s. Many of Elixir's naming conventions come from Erlang's established patterns:\n",
        "\n",
        "- Erlang used `upcase`/`downcase` \n",
        "- Ruby also uses `upcase`/`downcase`\n",
        "- Jose Valim (Elixir's creator) came from Ruby, so he kept familiar patterns\n",
        "\n",
        "## Different Language Communities, Different Conventions\n",
        "\n",
        "**Python tradition:** `upper()`, `lower()`  \n",
        "**Ruby/Erlang tradition:** `upcase()`, `downcase()`  \n",
        "**JavaScript tradition:** `toUpperCase()`, `toLowerCase()`\n",
        "\n",
        "None is \"more correct\" - they're just different community conventions that evolved independently.\n",
        "\n",
        "## The Search Strategy\n",
        "\n",
        "You're right that searching can be tricky! Here are better strategies:\n",
        "\n",
        "1. **Search for the concept, not the exact word**: Search \"case\" instead of \"upper\"\n",
        "2. **Use the module overview**: Look at `h String` first to see all available functions\n",
        "3. **Think in terms of the target language**: When in Elixir-land, think \"upcase\" not \"upper\"\n",
        "\n",
        "It's like learning that \"elevator\" (US) vs \"lift\" (UK) - same concept, different words. You just have to adapt to the local vocabulary!\n",
        "\n",
        "The good news: once you learn a few modules, the patterns become predictable.\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "Ah! I never realized that Ruby and Erlang had this kind of a convention. It's surprising how often we equate familiarity with correctness. Thanks for helping me confront my confirmation bias. \n",
        "So, what is the next detour?\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Exactly! That's a profound insight - familiarity often masquerades as correctness. It's one of the biggest hurdles when learning new languages or paradigms.\n",
        "\n",
        "Next few detours are about the variations of anonymous functions you have written as you will see them quite a lot - But before we tackle the more tricky aspects of the anon functions, you need to understand 2 things well - Everything is an Expression in Elixir and Why Parantheses are Optional in Elixir. \n",
        "\n",
        "# Detour - Everything is an Expression in Elixir\n",
        "\n",
        "One of the most fundamental differences between Elixir and Python is how they handle code execution. Understanding this difference is crucial to make the transition to an Elixir pro.\n",
        "\n",
        "## The Big Difference\n",
        "\n",
        "**Python** has both **statements** and **expressions**:\n",
        "- **Statements** do things but don't return values (`if`, `for`, `def`, etc.)\n",
        "- **Expressions** calculate and return values (`2 + 3`, `len(\"hello\")`, etc.)\n",
        "\n",
        "**Elixir** has only **expressions**:\n",
        "- Everything returns a value\n",
        "- Everything can be used wherever a value is expected\n",
        "\n",
        "## What This Means in Practice\n",
        "\n",
        "### Example 1: Basic Assignment and Function Calls\n",
        "\n",
        "**Python:**\n",
        "```python\n",
        "# This works - using expressions\n",
        "numbers = [1, 2, 3]\n",
        "result = len(numbers)  # len() is an expression, returns 3\n",
        "```\n",
        "\n",
        "**Elixir:**\n",
        "```elixir\n",
        "# This also works - everything is an expression\n",
        "numbers = [1, 2, 3]\n",
        "result = length(numbers)  # length() is an expression, returns 3\n",
        "```\n",
        "\n",
        "### Example 2: Using Conditional Logic\n",
        "\n",
        "**Python:**\n",
        "```python\n",
        "# This doesn't work - can't use if statement as expression\n",
        "# result = if True: 5 else: 3  # SyntaxError!\n",
        "\n",
        "# You need the ternary operator (which IS an expression)\n",
        "result = 5 if True else 3  # This works\n",
        "```\n",
        "\n",
        "**Elixir:**\n",
        "```elixir\n",
        "# This works perfectly - if is an expression that returns a value\n",
        "result = if true do\n",
        "  5\n",
        "else\n",
        "  3\n",
        "end\n",
        "# result is 5\n",
        "```\n",
        "\n",
        "### Example 3: Assignment Inside Function Calls\n",
        "\n",
        "**Python:**\n",
        "```python\n",
        "# Assignment is a statement, doesn't return a value\n",
        "x = 10\n",
        "# print(y = x + 5)  # SyntaxError! Assignment doesn't return anything\n",
        "```\n",
        "\n",
        "**Elixir:**\n",
        "```elixir\n",
        "# Assignment returns the assigned value\n",
        "x = 10\n",
        "IO.puts(y = x + 5)  # This works! Prints 15, and y is also set to 15\n",
        "```\n",
        "\n",
        "### Example 4: Complex Conditionals\n",
        "\n",
        "**Python:**\n",
        "```python\n",
        "# if is a statement - it does something but doesn't return a value\n",
        "x = 10\n",
        "if x > 5:\n",
        "    message = \"big number\"\n",
        "else:\n",
        "    message = \"small number\"\n",
        "\n",
        "print(message)  # \"big number\"\n",
        "```\n",
        "\n",
        "**Elixir:**\n",
        "```elixir\n",
        "# if is an expression - it returns a value\n",
        "x = 10\n",
        "message = if x > 5 do\n",
        "  \"big number\"\n",
        "else\n",
        "  \"small number\"\n",
        "end\n",
        "\n",
        "IO.puts(message)  # \"big number\"\n",
        "\n",
        "# You can even nest if expressions inside other expressions\n",
        "IO.puts(if x > 5 do\n",
        "  \"big number\"\n",
        "else\n",
        "  \"small number\"\n",
        "end)\n",
        "```\n",
        "\n",
        "### Example 5: Function Definitions\n",
        "\n",
        "**Python:**\n",
        "```python\n",
        "# def is a statement - creates a function but doesn't return it\n",
        "def add(x, y):\n",
        "    return x + y\n",
        "\n",
        "# Functions are objects, but def doesn't return the function\n",
        "# print(def add(x, y): return x + y)  # SyntaxError!\n",
        "\n",
        "# To create and use a function in one expression, you need lambda\n",
        "result = (lambda x, y: x + y)(3, 4)  # Returns 7\n",
        "```\n",
        "\n",
        "**Elixir:**\n",
        "```elixir\n",
        "# def is also used to create named functions\n",
        "def add(x, y) do\n",
        "  x + y\n",
        "end\n",
        "\n",
        "# In Elixir, you can't use def inside expressions either\n",
        "# IO.puts(def add(x, y), do: x + y)  # This won't work as expected!\n",
        "\n",
        "# To create and use a function in one expression, you use fn\n",
        "result = (fn x, y -> x + y end).(3, 4)  # Returns 7\n",
        "```\n",
        "\n",
        "## Pattern Matching: Also an Expression\n",
        "\n",
        "**Python:**\n",
        "```python\n",
        "# Assignment doesn't return a value\n",
        "# You can't do: print(x, y = (1, 2))  # SyntaxError!\n",
        "\n",
        "# You have to separate assignment from usage\n",
        "x, y = (1, 2)\n",
        "print(x, y)\n",
        "```\n",
        "\n",
        "**Elixir:**\n",
        "```elixir\n",
        "# Pattern matching returns the matched value\n",
        "IO.puts({x, y} = {1, 2})  # This works! Prints {1, 2}, and sets x=1, y=2\n",
        "\n",
        "# You can use pattern matching in complex expressions\n",
        "IO.puts(case {:ok, \"hello\"} do\n",
        "  {:ok, message} -> \"Success: #{message}\"\n",
        "  {:error, reason} -> \"Failed: #{reason}\"\n",
        "end)\n",
        "# Prints: \"Success: hello\"\n",
        "```\n",
        "\n",
        "## Why This Matters for Data Transformation\n",
        "\n",
        "**Python:**\n",
        "```python\n",
        "# You need to break operations into statements\n",
        "numbers = [1, 2, 3, 4, 5]\n",
        "doubled = [x * 2 for x in numbers]\n",
        "filtered = [x for x in doubled if x > 4]\n",
        "result = sum(filtered)\n",
        "# result is 18\n",
        "```\n",
        "\n",
        "**Elixir:**\n",
        "```elixir\n",
        "# You can chain and compose operations naturally\n",
        "result = [1, 2, 3, 4, 5]\n",
        "|> Enum.map(fn x -> x * 2 end)\n",
        "|> Enum.filter(fn x -> x > 4 end)\n",
        "|> Enum.sum()\n",
        "# result is 18\n",
        "\n",
        "# Each step returns a value that feeds into the next step\n",
        "```\n",
        "\n",
        "## The Mental Model\n",
        "\n",
        "**Python**: \"Do this, then do that, then do the other thing\"\n",
        "- Mix of statements (do things) and expressions (return values)\n",
        "- More verbose when chaining operations\n",
        "\n",
        "**Elixir**: \"Calculate this value by combining these smaller values\"\n",
        "- Everything returns a value\n",
        "- Natural composition and chaining\n",
        "- Functions are just expressions that return values\n",
        "\n",
        "This expression-oriented thinking is what makes Elixir's functional programming style so elegant and composable. When we later explore anonymous functions and the capture operator, you'll see how this \"everything returns a value\" principle makes the syntax feel natural and consistent.\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "That is beautiful - almost artistic. So, let us see why parantheses are optional. I am wondering how that is even possible.\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Great question! The optional parentheses in Elixir can seem magical at first, but there's elegant logic behind it.\n",
        "\n",
        "Read the detour and let me know if you have any questions. \n",
        "\n",
        "## Detour - Why Parentheses are Optional in Elixir \n",
        "\n",
        "One of the first things you'll notice when reading Elixir code is that parentheses around function arguments are often missing. Coming from languages like Python where parentheses are required, this can be confusing. Let's understand why Elixir allows this and when you actually need them.\n",
        "\n",
        "## The Foundation: Everything is an Expression\n",
        "\n",
        "As we covered in our previous discussion about expressions, Elixir treats everything as an expression that returns a value. This design philosophy extends to function calls - they're just expressions that happen to take arguments and return values.\n",
        "\n",
        "Since function calls are expressions, Elixir's parser can often figure out what you mean without requiring explicit parentheses.\n",
        "\n",
        "## Python vs Elixir: Function Call Syntax\n",
        "\n",
        "### Python: Parentheses Always Required\n",
        "\n",
        "```python\n",
        "# In Python, you MUST use parentheses for function calls\n",
        "len([1, 2, 3])          # Required\n",
        "print(\"hello\")          # Required\n",
        "str.upper(\"hello\")      # Required\n",
        "\n",
        "# Without parentheses, you get the function object, not a call\n",
        "len                     # Returns: <built-in function len>\n",
        "print                   # Returns: <built-in function print>\n",
        "```\n",
        "\n",
        "### Elixir: Parentheses Often Optional\n",
        "\n",
        "```elixir\n",
        "# In Elixir, parentheses are often optional\n",
        "length [1, 2, 3]        # Works fine\n",
        "IO.puts \"hello\"         # Works fine\n",
        "String.upcase \"hello\"   # Works fine\n",
        "\n",
        "# With parentheses (also valid)\n",
        "length([1, 2, 3])       # Also works\n",
        "IO.puts(\"hello\")        # Also works\n",
        "String.upcase(\"hello\")  # Also works\n",
        "```\n",
        "\n",
        "## When Parentheses Are Optional\n",
        "\n",
        "Parentheses can be omitted in most straightforward function calls:\n",
        "\n",
        "```elixir\n",
        "# Single argument\n",
        "IO.puts \"Hello World\"\n",
        "String.length \"elixir\"\n",
        "Integer.parse \"42\"\n",
        "\n",
        "# Multiple arguments\n",
        "String.replace \"hello world\", \"world\", \"elixir\"\n",
        "Enum.map [1, 2, 3], fn x -> x * 2 end\n",
        "Math.pow 2, 3\n",
        "```\n",
        "\n",
        "We have NOT covered piping in detail, but just skim it to get an idea - this is intended as a starter to whet your appetite; full-course will be served in due time.\n",
        "\n",
        "```\n",
        "# Chained function calls (pipe operator)\n",
        "\"hello world\"\n",
        "|> String.upcase\n",
        "|> String.reverse\n",
        "|> IO.puts\n",
        "```\n",
        "\n",
        "## When Parentheses Are Required\n",
        "\n",
        "There are several situations where you MUST use parentheses:\n",
        "\n",
        "### 1. Zero-Argument Functions\n",
        "\n",
        "```elixir\n",
        "# Zero arguments - parentheses required\n",
        "System.system_time()   # Must have parentheses\n",
        ":rand.uniform()        # Must have parentheses - the atom style module refers to Erlang modules. Not imporant for now, but just take a note!\n",
        "\n",
        "# Without parentheses, you're referencing the function, not calling it\n",
        "# System.system_time   # What is your intention here? Referencing or calling - not clear!\n",
        "```\n",
        "\n",
        "### 2. Nested Function Calls\n",
        "\n",
        "```elixir\n",
        "# When nesting function calls, inner calls need parentheses for clarity\n",
        "String.length(String.upcase(\"hello\"))\n",
        "\n",
        "# Without parentheses, this becomes ambiguous:\n",
        "# String.length String.upcase \"hello\"  # Confusing - which function gets what?\n",
        "```\n",
        "\n",
        "## Real Examples from Our Previous Writeups\n",
        "\n",
        "Let's look at examples from our anonymous functions writeup to see this in practice:\n",
        "\n",
        "### Example 1: String Operations\n",
        "\n",
        "```elixir\n",
        "# From our fruits example - both styles work\n",
        "fruits = [\"apple\", \"banana\", \"cherry\"]\n",
        "\n",
        "# Without parentheses (readable for simple cases)\n",
        "Enum.map fruits, fn x -> String.upcase x end\n",
        "\n",
        "# With parentheses (clearer, generally better for complex cases, not for toy ones like this)\n",
        "Enum.map(fruits, fn x -> String.upcase(x) end)\n",
        "\n",
        "```\n",
        "\n",
        "### Example 2: Math Operations\n",
        "\n",
        "```elixir\n",
        "# From our prices example\n",
        "prices = [10.0, 25.50, 8.75]\n",
        "\n",
        "# Without parentheses\n",
        "Enum.map prices, fn x -> x * 1.08 end\n",
        "\n",
        "# With parentheses (recommended for clarity)\n",
        "Enum.map(prices, fn x -> x * 1.08 end)\n",
        "\n",
        "```\n",
        "\n",
        "### Example 3: Nested Function Calls\n",
        "\n",
        "```elixir\n",
        "# From our words example\n",
        "words = [\"cat\", \"elephant\", \"dog\", \"butterfly\"]\n",
        "\n",
        "# This needs parentheses for the inner function call\n",
        "Enum.map(words, fn x -> String.length(x) end)\n",
        "\n",
        "```\n",
        "\n",
        "## The Mental Model: When to Use Parentheses\n",
        "\n",
        "Think of parentheses as **clarity markers**:\n",
        "\n",
        "### Use parentheses when:\n",
        "- **Zero arguments**: Always required\n",
        "- **Nested calls**: Required for inner functions\n",
        "- **Complex expressions**: When it makes the code clearer\n",
        "\n",
        "### Skip parentheses when:\n",
        "- **Simple, single function calls**: `IO.puts \"hello\"`\n",
        "- **Pipe operations**: `data |> transform |> output`\n",
        "- **The meaning is completely clear**: `String.upcase \"hello\"`\n",
        "\n",
        "Elixir's optional parentheses support the language's philosophy:\n",
        "\n",
        "1. **Readability**: Code can look more like natural language\n",
        "2. **Flexibility**: You can choose the style that makes your code clearest\n",
        "3. **Pipe operator**: Supports the elegant `|>` chaining syntax\n",
        "4. **Expression-oriented**: Everything is an expression, so the syntax stays consistent\n",
        "\n",
        "This flexibility, combined with Elixir's \"everything is an expression\" design, creates a language that's both powerful and readable. When we explore anonymous functions and the capture operator next, you'll see how this optional parentheses feature makes functional programming patterns feel more natural.\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "That is nice - yes, the piping syntax looks inviting and it is one of thing that everyone seems to praise about Elixir. But what comes next in our coverage of anonymous functions?\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Great! Now that you understand expressions and optional parentheses, let's explore the different ways to write anonymous functions in Elixir. You've been using the basic `fn` syntax, but there are several variations that make code more concise. Let us start with the shorter syntax which you will see a lot in Phoenix code. \n",
        "\n",
        "## Detour - Elixir Anonymous Functions - Shorter Syntax\n",
        "\n",
        "When you're transforming data in Elixir, you often write simple anonymous functions that just take one input and apply one function to it. Elixir has a shorter way to write these.\n",
        "\n",
        "## The Problem: Repetitive Anonymous Functions\n",
        "\n",
        "Look at the three examples you have code under the first functional pattern - Map:\n",
        "\n",
        "```elixir\n",
        "# Example 1: Convert fruits to uppercase\n",
        "fruits = [\"apple\", \"banana\", \"cherry\"]\n",
        "Enum.map(fruits, fn x -> String.upcase(x) end)\n",
        "# Result: [\"APPLE\", \"BANANA\", \"CHERRY\"]\n",
        "\n",
        "# Example 2: Add tax to prices  \n",
        "prices = [10.0, 25.50, 8.75]\n",
        "Enum.map(prices, fn x -> x * 1.08 end)\n",
        "# Result: [10.8, 27.54, 9.45]\n",
        "\n",
        "# Example 3: Get word lengths\n",
        "words = [\"cat\", \"elephant\", \"dog\", \"butterfly\"]\n",
        "Enum.map(words, fn x -> String.length(x) end)\n",
        "# Result: [3, 8, 3, 9]\n",
        "```\n",
        "\n",
        "Notice the pattern: `fn x -> some_function(x) end` appears often!\n",
        "\n",
        "## The Solution: The Capture Operator &\n",
        "\n",
        "Elixir provides a special operator called the **capture operator** (`&`) that creates anonymous functions with shorter syntax:\n",
        "\n",
        "```elixir\n",
        "# Long way vs Short way\n",
        "\n",
        "# Example 1: String.upcase\n",
        "Enum.map(fruits, fn x -> String.upcase(x) end)\n",
        "Enum.map(fruits, &String.upcase/1)              # Shorter!\n",
        "\n",
        "# Example 2: Math operation  \n",
        "Enum.map(prices, fn x -> x * 1.08 end)\n",
        "Enum.map(prices, &(&1 * 1.08))                 # Shorter!\n",
        "\n",
        "# Example 3: String.length\n",
        "Enum.map(words, fn x -> String.length(x) end)\n",
        "Enum.map(words, &String.length/1)              # Shorter!\n",
        "```\n",
        "\n",
        "## What is the Capture Operator?\n",
        "\n",
        "The `&` symbol is called the **capture operator**. It \"captures\" functions and expressions to create anonymous functions quickly.\n",
        "\n",
        "Think of it as saying: \"Capture this and turn it into a function I can pass around.\"\n",
        "\n",
        "## Two Types of Short Syntax\n",
        "\n",
        "### **Type 1: Capturing Existing Functions (`&Module.function/arity`)**\n",
        "\n",
        "When you want to \"capture\" an existing function to use it as an anonymous function:\n",
        "\n",
        "```elixir\n",
        "# Pattern: fn x -> Module.function(x) end\n",
        "# Shortcut: &Module.function/1\n",
        "\n",
        "&String.upcase/1    # Same as: fn x -> String.upcase(x) end\n",
        "&String.length/1    # Same as: fn x -> String.length(x) end\n",
        "```\n",
        "\n",
        "### **Type 2: Capturing Expressions (`&(&1 + something)`)**\n",
        "\n",
        "This is where the capture operator gets more interesting - you can \"capture\" entire expressions and turn them into functions automatically.\n",
        "\n",
        "**The Basic Pattern:**\n",
        "\n",
        "elixir\n",
        "\n",
        "```elixir\n",
        "# Instead of writing this long form:\n",
        "fn x -> x + something end\n",
        "\n",
        "# You can write this shortcut:\n",
        "&(&1 + something)\n",
        "```\n",
        "\n",
        "**What's happening here?**\n",
        "\n",
        "- The outer `&` tells Elixir \"make this into a function\"\n",
        "- `&1` represents the first argument that will be passed to the function\n",
        "- Everything else is the expression you want to perform on that argument\n",
        "\n",
        "\n",
        "```elixir\n",
        "# Examples\n",
        "\n",
        "&(&1 * 1.08)        # Same as: fn x -> x * 1.08 end\n",
        "&(&1 + 5)           # Same as: fn x -> x + 5 end\n",
        "&(&1 + &2)          # Same as: fn x, y -> x + y end\n",
        "```\n",
        "\n",
        "\n",
        "## Function/Arity Combo\n",
        "\n",
        "I hope you still remember function/arity combo we discussed a while back. So, it is NOT just a concept to understand, it is a way to communicate with the Elixir compiler. \n",
        "\n",
        "The `/n` tells Elixir how many arguments the function takes:\n",
        "\n",
        "- `String.upcase/1` - takes 1 argument\n",
        "- `String.replace/3` - takes 3 arguments\n",
        "- `Enum.map/2` - takes 2 arguments\n",
        "\n",
        "## Comparing with Python\n",
        "\n",
        "Let's see how this compares to Python's approach:\n",
        "\n",
        "**Python** - Using existing functions in map:\n",
        "\n",
        "```python\n",
        "# Python hides the function creation\n",
        "fruits = [\"apple\", \"banana\", \"cherry\"]\n",
        "list(map(str.upper, fruits))        # A bit harder to read, but module name gives it away that a function is being used...\n",
        "\n",
        "words = [\"cat\", \"elephant\", \"dog\", \"butterfly\"] \n",
        "list(map(len, words))               # hard to know what len is - is it a variable or a function? \n",
        "```\n",
        "\n",
        "**Elixir** - Explicit capture operator:\n",
        "\n",
        "```elixir\n",
        "# Elixir makes it clear you're creating a function\n",
        "fruits = [\"apple\", \"banana\", \"cherry\"]\n",
        "Enum.map(fruits, &String.upcase/1)  # The & says \"I'm making a function\"\n",
        "\n",
        "words = [\"cat\", \"elephant\", \"dog\", \"butterfly\"]\n",
        "Enum.map(words, &String.length/1)   # Crystal clear what's happening\n",
        "```\n",
        "\n",
        "The capture operator makes it **explicit** that you're creating an anonymous function, while Python's syntax can be confusing - you might not realize `str.upper` is being turned into a function behind the scenes.\n",
        "\n",
        "## The Mental Model\n",
        "\n",
        "The capture operator `&` is like saying \"capture this and make it into a function\":\n",
        "\n",
        "- `&String.upcase/1` → \"capture the upcase function so I can pass it around\"\n",
        "- `&(&1 * 2)` → \"capture this expression and make it a function that doubles its input\"\n",
        "\n",
        "You're literally **capturing** existing functions or expressions to create new anonymous functions!\n",
        "\n",
        "This shorter syntax keeps your code clean when doing simple transformations!\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "Hmm. That reminds of the C days - pointers and addresses, etc. Anyway, I do agree that the syntax is shorter and compared to reading Python, it is more explicit. I am not sure whether I like it or not - I will let you know after I have used it for a while.\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "That's a very mature approach! You're absolutely right to reserve judgment until you've used it in practice. The C pointer analogy is interesting - there is some similarity in that you're \"pointing to\" or \"referencing\" functions.\n",
        "\n",
        "Your instinct to wait and see is spot-on. Some developers love the conciseness of `&String.upcase/1`, while others prefer the explicitness of `fn x -> String.upcase(x) end`. Both are perfectly valid Elixir, and you'll develop your own preference over time.\n",
        "\n",
        "The good news is that understanding both syntaxes means you can read any Elixir code you encounter, regardless of which style the author preferred.\n",
        "\n",
        "For now, feel free to stick with the `fn x -> ... end` syntax in your own code if it feels more comfortable. You can always experiment with the capture operator later when you're more settled with Elixir's other concepts.\n",
        "\n",
        "Ready for the next detour? Our next detour is a bit involved - so, get your coffee, if needed. Though it might feel like an advanced topic at this stage, you will see this very often in the wild and I want you to be clear about the subtle differences between Elixir and Python with respect to anonymous functions and how they are used. \n",
        "\n",
        "## Detour - The Dot Syntax for calling Anonymous Functions\n",
        "\n",
        "In Elixir, there's a special syntax you need to use when calling anonymous functions **that are stored in variables**. This might seem strange at first, but once you understand it, it becomes second nature.\n",
        "\n",
        "## The Rule: Anonymous Functions in Variables Need a Dot\n",
        "\n",
        "When you have an anonymous function stored in a variable, you **must** use a dot (`.`) before the parentheses to call it.\n",
        "\n",
        "```elixir\n",
        "# This is the syntax for functions stored in variables:\n",
        "my_function = fn x -> x * 2 end\n",
        "my_function.(arguments)\n",
        "#           ↑ Notice the dot here!\n",
        "```\n",
        "\n",
        "**Important**: You only need the dot when the function is stored in a variable. When you write anonymous functions inline (like in `Enum.map`), no dot is needed:\n",
        "\n",
        "```elixir\n",
        "# ✅ Inline anonymous function - no dot needed\n",
        "Enum.map([1, 2, 3], fn x -> x * 2 end)\n",
        "\n",
        "# ✅ Function stored in variable - dot required when calling\n",
        "double = fn x -> x * 2 end\n",
        "double.(5)  # Notice the dot\n",
        "\n",
        "# ✅ Using the stored function with Enum.map - still no dot in the map call\n",
        "Enum.map([1, 2, 3], double)  # We're passing the function, not calling it\n",
        "```\n",
        "\n",
        "## Why the Dot?\n",
        "\n",
        "The dot syntax exists because **parentheses are optional in Elixir**. This creates a fundamental ambiguity that doesn't exist in Python.\n",
        "\n",
        "Here's where the problem becomes clear - imagine this function:\n",
        "\n",
        "```elixir\n",
        "def get_tax_calculator do\n",
        "  add_tax = fn price -> price * 1.08 end\n",
        "  \n",
        "  # Without the dot rule, what does this line mean?\n",
        "  add_tax    # Am I returning the function or calling it with no args?\n",
        "end\n",
        "```\n",
        "\n",
        "**In Python, parentheses make the intent crystal clear:**\n",
        "\n",
        "```python\n",
        "def get_tax_calculator():\n",
        "    def add_tax(price):\n",
        "        return price * 1.08\n",
        "    \n",
        "    return add_tax      # Clearly returning the function (no parentheses)\n",
        "    # return add_tax()  # Would clearly be calling it (has parentheses)\n",
        "```\n",
        "\n",
        "**But Elixir allows both of these to mean \"call the function\":**\n",
        "\n",
        "```elixir\n",
        "# These are equivalent in Elixir for named functions:\n",
        "String.upcase(\"hello\")    # With parentheses\n",
        "String.upcase \"hello\"     # Without parentheses - both call the function!\n",
        "```\n",
        "\n",
        "So for anonymous functions stored in variables, Elixir needs the dot to distinguish:\n",
        "\n",
        "```elixir\n",
        "def get_tax_calculator do\n",
        "  add_tax = fn price -> price * 1.08 end\n",
        "  \n",
        "  add_tax           # Return the function (no dot)\n",
        "end\n",
        "\n",
        "def calculate_price(base_price) do\n",
        "  add_tax = fn price -> price * 1.08 end\n",
        "  \n",
        "  add_tax.(base_price)  # Call the function (dot + argument)\n",
        "end\n",
        "```\n",
        "\n",
        "The dot prevents ambiguity between \"use this function\" vs \"call this function\" in a language where parentheses are optional.\n",
        "\n",
        "## Examples: Simple Case (Single Parameter, No Extra Processing)\n",
        "\n",
        "Let's start with the simplest case where your stored function takes exactly one parameter and needs no additional processing.\n",
        "\n",
        "### Example 1: Uppercasing Strings\n",
        "\n",
        "**Elixir:**\n",
        "\n",
        "```elixir\n",
        "# Inline version (no dot needed)\n",
        "fruits = [\"apple\", \"banana\", \"cherry\"]\n",
        "Enum.map(fruits, fn x -> String.upcase(x) end)\n",
        "# Result: [\"APPLE\", \"BANANA\", \"CHERRY\"]\n",
        "\n",
        "# Stored function version\n",
        "uppercase_fn = fn x -> String.upcase(x) end\n",
        "Enum.map(fruits, uppercase_fn)  # Pass the function directly (no dot)\n",
        "# Result: [\"APPLE\", \"BANANA\", \"CHERRY\"]\n",
        "```\n",
        "\n",
        "**Python:**\n",
        "\n",
        "```python\n",
        "# Inline version\n",
        "fruits = [\"apple\", \"banana\", \"cherry\"]\n",
        "list(map(lambda x: x.upper(), fruits))\n",
        "# Result: [\"APPLE\", \"BANANA\", \"CHERRY\"]\n",
        "\n",
        "# Stored function version\n",
        "def uppercase_fn(x):\n",
        "    return x.upper()\n",
        "\n",
        "list(map(uppercase_fn, fruits))  # Pass the function directly (no parentheses)\n",
        "# Result: [\"APPLE\", \"BANANA\", \"CHERRY\"]\n",
        "```\n",
        "\n",
        "### Example 2: Adding Tax to Prices\n",
        "\n",
        "**Elixir:**\n",
        "\n",
        "```elixir\n",
        "# Inline version\n",
        "prices = [10.0, 25.50, 8.75]\n",
        "Enum.map(prices, fn x -> x * 1.08 end)\n",
        "# Result: [10.8, 27.54, 9.45]\n",
        "\n",
        "# Stored function version\n",
        "add_tax = fn x -> x * 1.08 end\n",
        "Enum.map(prices, add_tax)  # Pass the function directly\n",
        "# Result: [10.8, 27.54, 9.45]\n",
        "```\n",
        "\n",
        "**Python:**\n",
        "\n",
        "```python\n",
        "# Inline version\n",
        "prices = [10.0, 25.50, 8.75]\n",
        "list(map(lambda x: x * 1.08, prices))\n",
        "# Result: [10.8, 27.54, 9.45]\n",
        "\n",
        "# Stored function version\n",
        "def add_tax(x):\n",
        "    return x * 1.08\n",
        "\n",
        "list(map(add_tax, prices))  # Pass the function directly\n",
        "# Result: [10.8, 27.54, 9.45]\n",
        "```\n",
        "\n",
        "**Key Point:** For simple cases, both languages work similarly - you can pass the stored function directly without calling it.\n",
        "\n",
        "## Examples: Complex Case (Additional Processing Needed)\n",
        "\n",
        "Sometimes you need to do more than just call your stored function - maybe add extra processing or combine it with other operations.\n",
        "\n",
        "### Example: Uppercasing + Adding Exclamation\n",
        "\n",
        "**Elixir:**\n",
        "\n",
        "```elixir\n",
        "uppercase_fn = fn x -> String.upcase(x) end\n",
        "fruits = [\"apple\", \"banana\", \"cherry\"]\n",
        "\n",
        "# Need to call the function AND add \"!\" - requires the dot syntax\n",
        "Enum.map(fruits, &(uppercase_fn.(&1) <> \"!\"))\n",
        "# Result: [\"APPLE!\", \"BANANA!\", \"CHERRY!\"]\n",
        "```\n",
        "\n",
        "**Python:**\n",
        "\n",
        "```python\n",
        "def uppercase_fn(x):\n",
        "    return x.upper()\n",
        "\n",
        "fruits = [\"apple\", \"banana\", \"cherry\"]\n",
        "\n",
        "# Need to call the function AND add \"!\" - requires a lambda\n",
        "list(map(lambda x: uppercase_fn(x) + \"!\", fruits))\n",
        "# Result: [\"APPLE!\", \"BANANA!\", \"CHERRY!\"]\n",
        "```\n",
        "\n",
        "### Example: Tax Calculation + Rounding\n",
        "\n",
        "**Elixir:**\n",
        "\n",
        "```elixir\n",
        "add_tax = fn x -> x * 1.08 end\n",
        "prices = [10.0, 25.50, 8.75]\n",
        "\n",
        "# Call the function AND round the result\n",
        "Enum.map(prices, &Float.round(add_tax.(&1), 2))\n",
        "# Result: [10.8, 27.54, 9.45]\n",
        "```\n",
        "\n",
        "**Python:**\n",
        "\n",
        "```python\n",
        "def add_tax(x):\n",
        "    return x * 1.08\n",
        "\n",
        "prices = [10.0, 25.50, 8.75]\n",
        "\n",
        "# Call the function AND round the result\n",
        "list(map(lambda x: round(add_tax(x), 2), prices))\n",
        "# Result: [10.8, 27.54, 9.45]\n",
        "```\n",
        "\n",
        "**Key Point:** When you need additional processing, both languages require you to wrap the function call in a new function (capture syntax in Elixir, lambda in Python).\n",
        "\n",
        "## Examples: Multiple Parameters\n",
        "\n",
        "When your stored function takes multiple parameters, but `map` only provides one, you need to supply the extra arguments.\n",
        "\n",
        "### Example: Tax Rate + Fee Calculation\n",
        "\n",
        "**Elixir:**\n",
        "\n",
        "```elixir\n",
        "# Function that takes 3 parameters\n",
        "calculate_total = fn price, tax_rate, fee -> price * (1 + tax_rate) + fee end\n",
        "prices = [10.0, 25.50, 8.75]\n",
        "\n",
        "# map only gives us one arg (price), so we provide the other two\n",
        "Enum.map(prices, &calculate_total.(&1, 0.08, 2.0))\n",
        "# Result: [12.8, 29.54, 11.45]\n",
        "```\n",
        "\n",
        "**Python:**\n",
        "\n",
        "```python\n",
        "# Function that takes 3 parameters\n",
        "def calculate_total(price, tax_rate, fee):\n",
        "    return price * (1 + tax_rate) + fee\n",
        "\n",
        "prices = [10.0, 25.50, 8.75]\n",
        "\n",
        "# map only gives us one arg (price), so we provide the other two via lambda\n",
        "list(map(lambda price: calculate_total(price, 0.08, 2.0), prices))\n",
        "# Result: [12.8, 29.54, 11.45]\n",
        "```\n",
        "\n",
        "**Key Point:** Both languages handle multiple parameters the same way - you must create a new function that calls your stored function with the extra arguments provided.\n",
        "\n",
        "## Common Mistakes\n",
        "\n",
        "```elixir\n",
        "my_function = fn x -> x * 2 end\n",
        "\n",
        "# ❌ Wrong - missing the dot when calling directly\n",
        "my_function(5)\n",
        "\n",
        "# ✅ Correct - with the dot when calling directly\n",
        "my_function.(5)\n",
        "\n",
        "# ✅ Correct - no dot when passing to another function\n",
        "Enum.map([1, 2, 3], my_function)\n",
        "```\n",
        "\n",
        "## Remember\n",
        "\n",
        "- **Inline anonymous functions**: No dot needed → `Enum.map(list, fn x -> x * 2 end)`\n",
        "- **Stored anonymous functions when calling directly**: Use a dot → `my_function.(args)`\n",
        "- **Stored anonymous functions when passing to other functions**: No dot → `Enum.map(list, my_function)`\n",
        "- **Named functions**: No dot → `String.upcase(args)`\n",
        "- **The dot is only for calling stored anonymous functions** - not for inline functions or for named functions or when passing functions around\n",
        "\n",
        "This syntax might feel unusual coming from other languages, but it's one of Elixir's ways of making code more explicit and preventing common mistakes!\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "wow - that is a lot to digest - but I am happy you used the same 3 examples as in the previous detour - that reduces my mental strain so that I can focus only on what is new.\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Exactly! I'm glad you noticed that intentional choice. Using the same examples lets you focus purely on the new concept (the dot syntax) without having to juggle new problem domains at the same time.\n",
        "\n",
        "This is a key learning principle - when introducing complex concepts, keep everything else familiar so your brain can dedicate all its processing power to the new idea.\n",
        "\n",
        "The dot syntax for calling stored anonymous functions is definitely one of those \"Elixir quirks\" that feels strange at first but becomes second nature with practice. The key thing to remember is:\n",
        "\n",
        "- **Calling directly**: `my_function.(args)` ← needs the dot\n",
        "- **Passing around**: `Enum.map(list, my_function)` ← no dot\n",
        "\n",
        "You'll encounter this pattern frequently in real Elixir code, so it's worth understanding now even if it feels a bit heavy.\n",
        "\n",
        "Ready to move on from these detours and get back to our functional patterns? We still have **FILTER** and **REDUCE** to explore!\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "## Core Functional Pattern 2 - Filter\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "That was a lot of detours - But before we tackle the next pattern - can you do 2 summaries - one overall summary that summarizes all that we have covered so far. Then the next summary about the 3 core functional patterns and what we have covered there.\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "## Overall Summary: Everything We've Covered So Far\n",
        "\n",
        "### **Core Concepts Mastered** ✅\n",
        "\n",
        "**1. Pattern Matching**\n",
        "- `=` as match operator (bidirectional equality, not assignment)\n",
        "- Explicit structure matching: `[a, b, c] = list`\n",
        "- Head/tail decomposition: `[head | tail] = list`\n",
        "- Data validation through pattern matching\n",
        "- Pin operator `^` for matching existing variables\n",
        "\n",
        "**2. Immutability**\n",
        "- No mutations - data never changes after creation\n",
        "- Functions return new data instead of modifying existing\n",
        "- Safe sharing - no surprise side effects\n",
        "- Memory efficiency through structural sharing\n",
        "\n",
        "**3. IEx and Documentation**\n",
        "- Function arity notation: `function_name/number_of_arguments`\n",
        "- `h` for help, `i` for inspecting data types\n",
        "- Every expression returns a value\n",
        "\n",
        "**4. Key Language Features**\n",
        "- Everything is an expression (vs Python's statements + expressions)\n",
        "- Optional parentheses (with clear rules about when required)\n",
        "- Modules organize functions (vs Python's object methods)\n",
        "- String interpolation: `\"#{variable}\"`\n",
        "\n",
        "**5. Anonymous Functions**\n",
        "- Basic syntax: `fn x -> transformation end`\n",
        "- Capture operator: `&String.upcase/1` and `&(&1 * 2)`\n",
        "- Dot syntax for calling stored functions: `my_function.(args)`\n",
        "\n",
        "---\n",
        "\n",
        "## Functional Patterns Summary\n",
        "\n",
        "### **The 3 Core Patterns**\n",
        "1. **MAP** - Transform each item (same number out as in)\n",
        "2. **FILTER** - Keep only some items (fewer or same number out)\n",
        "3. **REDUCE** - Combine all into one result (single value out)\n",
        "\n",
        "### **What We've Covered**\n",
        "\n",
        "**MAP Pattern** ✅ **COMPLETED**\n",
        "- `Enum.map(collection, transformation_function)`\n",
        "- Examples mastered:\n",
        "  - Uppercasing strings: `Enum.map(fruits, fn x -> String.upcase(x) end)`\n",
        "  - Adding tax: `Enum.map(prices, fn x -> x * 1.08 end)`\n",
        "  - String lengths: `Enum.map(words, fn x -> String.length(x) end)`\n",
        "\n",
        "**FILTER Pattern** ⏳ **NEXT UP**\n",
        "- Keep only items that meet a condition\n",
        "- Examples to explore: filtering by length, positive numbers, etc.\n",
        "\n",
        "**REDUCE Pattern** ⏳ **COMING SOON**\n",
        "- Combine all items into single result\n",
        "- Examples to explore: sum, max, count, join strings\n",
        "\n",
        "Ready to tackle **FILTER**?\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "that is a wonderful summary - let us start filtering now.\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Perfect! Let's dive into the **FILTER** pattern.\n",
        "\n",
        "First I want to give you an overview of the 3 examples we will work through to help you practice Filtering in Elixir. \n",
        "\n",
        "Remember the mental model: **\"I want to keep only items that meet a condition\"**\n",
        "\n",
        "The pattern: Input list → Fewer (or same) items → Same values\n",
        "\n",
        "## Filter Pattern - 3 Examples to Master\n",
        "\n",
        "**Example 2.1: Filter by string length**\n",
        "```python\n",
        "words = [\"cat\", \"elephant\", \"dog\", \"butterfly\"]\n",
        "# Only long words\n",
        "[word for word in words if len(word) > 5]\n",
        "# Result: [\"elephant\", \"butterfly\"]\n",
        "```\n",
        "\n",
        "**Example 2.2: Filter by numeric condition**\n",
        "```python\n",
        "numbers = [1, -2, 3, -4, 5, 0]\n",
        "# Only positive numbers\n",
        "[num for num in numbers if num > 0]\n",
        "# Result: [1, 3, 5]\n",
        "```\n",
        "\n",
        "**Example 2.3: Filter by string pattern**\n",
        "```python\n",
        "fruits = [\"apple\", \"banana\", \"cherry\", \"apricot\"]\n",
        "# Only fruits starting with \"a\"\n",
        "[fruit for fruit in fruits if fruit.startswith(\"a\")]\n",
        "# Result: [\"apple\", \"apricot\"]\n",
        "```\n",
        "\n",
        "\n",
        "Now that you have seen what is coming, Ready to tackle Example 2.1?\n",
        "\n",
        "## Filter 2.1 : Only long words\n",
        "\n",
        "Let's start with a simple example. Here's the Python code to translate:\n",
        "\n",
        "**Python:**\n",
        "```python\n",
        "words = [\"cat\", \"elephant\", \"dog\", \"butterfly\"]\n",
        "[word for word in words if len(word) > 5]  # Keep only long words\n",
        "# Result: [\"elephant\", \"butterfly\"]\n",
        "```\n",
        "\n",
        "You'll need to find the right function in the `Enum` module. Try looking up \"filter\" in the Enum documentation (`h Enum` and search for filter-related functions).\n",
        "\n",
        "Once you find the right function, try translating this Python code to Elixir. You already know how to:\n",
        "- Write anonymous functions: `fn word -> ... end`\n",
        "- Get string length: `String.length(word)`\n",
        "- Compare with `>`\n",
        "\n",
        "Give it a try!\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "I got it \n",
        "```elixir\n",
        "words = [\"cat\", \"elephant\", \"dog\", \"butterfly\"]\n",
        "Enum.filter(words, fn x -> String.length(x) > 5 end)\n",
        "```\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Excellent! You nailed it perfectly. You correctly identified:\n",
        "\n",
        "✅ `Enum.filter` as the right function  \n",
        "✅ Anonymous function structure: `fn x -> condition end`  \n",
        "✅ `String.length(x) > 5` as the condition  \n",
        "✅ The condition returns `true`/`false` to decide what to keep  \n",
        "\n",
        "Your result should be `[\"elephant\", \"butterfly\"]` - exactly the words longer than 5 characters.\n",
        "\n",
        "Notice the pattern: `Enum.filter(collection, fn item -> boolean_condition end)`\n",
        "\n",
        "The function you pass to `filter` must return `true` (keep the item) or `false` (discard it).\n",
        "\n",
        "Ready for Example 2.2? This one involves numbers instead of strings:\n",
        "\n",
        "**Python:**\n",
        "```python\n",
        "numbers = [1, -2, 3, -4, 5, 0]\n",
        "[num for num in numbers if num > 0]  # Keep only positive numbers\n",
        "# Result: [1, 3, 5]\n",
        "```\n",
        "\n",
        "This should be even simpler than the string example. Give it a shot!\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "Yes done - easy, peasy\n",
        "```elixir\n",
        "numbers = [1, -2, 3, -4, 5, 0]\n",
        "Enum.filter(numbers, fn x -> x > 0 end)\n",
        "```\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Perfect! You're getting the hang of this pattern. Much simpler indeed - no need for any module functions, just a direct comparison `x > 0`.\n",
        "\n",
        "Your result should be `[1, 3, 5]` - all the positive numbers.\n",
        "\n",
        "Now let's try the final filter example, which introduces string pattern matching:\n",
        "\n",
        "**Python:**\n",
        "```python\n",
        "fruits = [\"apple\", \"banana\", \"cherry\", \"apricot\"]\n",
        "[fruit for fruit in fruits if fruit.startswith(\"a\")]  # Keep only fruits starting with \"a\"\n",
        "# Result: [\"apple\", \"apricot\"]\n",
        "```\n",
        "\n",
        "For this one, you'll need to find the Elixir equivalent of Python's `startswith()` method. Try looking in the `String` module documentation (`h String`) for functions related to checking the beginning of strings.\n",
        "\n",
        "Give it a try!\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "Filter examples are very easy and I am really liking the repetition I get from the slightly varied tasks that help me to recall the new syntax multiple times.  \n",
        "```elixir\n",
        "fruits = [\"apple\", \"banana\", \"cherry\", \"apricot\"]\n",
        "Enum.filter(fruits, fn x -> String.starts_with?(x, \"a\") end)\n",
        "```\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Excellent! You found `String.starts_with?/2` perfectly. Notice how Elixir uses the `?` suffix to indicate functions that return `true`/`false` - this is a helpful convention you'll see throughout Elixir.\n",
        "\n",
        "Your result should be `[\"apple\", \"apricot\"]` - exactly the fruits starting with \"a\".\n",
        "\n",
        "I'm glad you're enjoying the repetitive practice with variations! That's exactly the learning approach we discussed - building muscle memory through spaced repetition with slight changes. You're now seeing the same core pattern:\n",
        "\n",
        "`Enum.filter(collection, fn item -> boolean_condition end)`\n",
        "\n",
        "But with different conditions:\n",
        "- String length: `String.length(x) > 5`\n",
        "- Numeric comparison: `x > 0`  \n",
        "- String pattern: `String.starts_with?(x, \"a\")`\n",
        "\n",
        "## Filter Pattern Summary ✅ **COMPLETED**\n",
        "\n",
        "You've mastered filtering! The pattern is always:\n",
        "- Input: A collection\n",
        "- Function: Returns `true` (keep) or `false` (discard)\n",
        "- Output: Same values, but fewer items\n",
        "\n",
        "Ready to tackle the final pattern: **REDUCE**? This one combines all items into a single result - it's the most powerful of the three patterns!\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "## Core Functional Pattern 3 - Reduce\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "yes - let us start REDUCING...\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Excellent! Let's dive into the **REDUCE** pattern - the most powerful of the three!\n",
        "\n",
        "Remember the mental model: **\"I want to combine all items into a single result\"**\n",
        "\n",
        "The pattern: Input list → Single result\n",
        "\n",
        "## Reduce Pattern - 3 Examples to Master\n",
        "\n",
        "**Example 3.1: Sum all numbers**\n",
        "```python\n",
        "numbers = [1, 2, 3, 4, 5]\n",
        "sum(numbers)  # Combine into total\n",
        "# Result: 15\n",
        "```\n",
        "\n",
        "**Example 3.2: Find maximum**\n",
        "```python\n",
        "numbers = [3, 1, 4, 1, 5, 9, 2]\n",
        "max(numbers)  # Combine into largest value\n",
        "# Result: 9\n",
        "```\n",
        "\n",
        "**Example 3.3: Join strings**\n",
        "```python\n",
        "words = [\"Hello\", \"beautiful\", \"world\"]\n",
        "\", \".join(words)  # Combine into single string\n",
        "# Result: \"Hello, beautiful, world\"\n",
        "```\n",
        "\n",
        "## Reduce 3.1: Sum all numbers\n",
        "\n",
        "Let's start with the classic example:\n",
        "\n",
        "**Python:**\n",
        "```python\n",
        "numbers = [1, 2, 3, 4, 5]\n",
        "sum(numbers)  # Result: 15\n",
        "```\n",
        "\n",
        "For this, you'll need to find the right function in the `Enum` module. Try looking for \"sum\" or \"reduce\" functions (`h Enum`).\n",
        "\n",
        "The reduce pattern is a bit different from map and filter - it builds up a result by combining each item with what came before.\n",
        "\n",
        "Give it a try!\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "rather than just showing only sum, can you also show the variant using reduce in python also - otherwise, this exercise is not challenging at all\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Great point! You're absolutely right - just using `sum()` doesn't teach you the reduce pattern. Let me show you both approaches in Python:\n",
        "\n",
        "**Python - Easy way (built-in function):**\n",
        "```python\n",
        "numbers = [1, 2, 3, 4, 5]\n",
        "sum(numbers)  # Result: 15\n",
        "```\n",
        "\n",
        "**Python - Reduce way (shows the pattern):**\n",
        "```python\n",
        "from functools import reduce\n",
        "numbers = [1, 2, 3, 4, 5]\n",
        "reduce(lambda acc, x: acc + x, numbers, 0)  # Result: 15\n",
        "```\n",
        "\n",
        "The reduce pattern works like this:\n",
        "- Start with an initial value (accumulator): `0`\n",
        "- For each item in the list: combine `accumulator + current_item`\n",
        "- The accumulator builds up: `0 + 1 = 1`, then `1 + 2 = 3`, then `3 + 3 = 6`, etc.\n",
        "\n",
        "Now translate **both versions** to Elixir:\n",
        "1. Find the Elixir equivalent of Python's `sum()`\n",
        "2. Find the Elixir equivalent of Python's `reduce()` and write the explicit version\n",
        "\n",
        "This will help you understand both the convenient shortcut and the underlying pattern!\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "Thanks. I got it - I almost cheated as I saw the code for summing as the first example when I did `h Enum.reduce`\n",
        "```elixir\n",
        "iex(42)> numbers = [1, 2, 3, 4, 5]\n",
        "[1, 2, 3, 4, 5]\n",
        "iex(43)> Enum.sum(numbers)\n",
        "15\n",
        "iex(44)> Enum.reduce(numbers, fn x, acc -> x + acc end)\n",
        "15\n",
        "```\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Perfect! You found both approaches:\n",
        "\n",
        "✅ `Enum.sum(numbers)` - the convenient shortcut  \n",
        "✅ `Enum.reduce(numbers, fn x, acc -> x + acc end)` - the explicit pattern\n",
        "\n",
        "Great observation about \"almost cheating\" by seeing the example in the docs - that's exactly how real programming works! Reading documentation and examples is a core skill.\n",
        "\n",
        "Now, Let's tackle Example 3.2 - finding the maximum value.\n",
        "\n",
        "**Python - Easy way (built-in function):**\n",
        "```python\n",
        "numbers = [3, 1, 4, 1, 5, 9, 2]\n",
        "max(numbers)  # Result: 9\n",
        "```\n",
        "\n",
        "**Python - Reduce way (shows the pattern):**\n",
        "```python\n",
        "from functools import reduce\n",
        "numbers = [3, 1, 4, 1, 5, 9, 2]\n",
        "reduce(lambda acc, x: max(acc, x), numbers)  # Result: 9\n",
        "# Or equivalently: reduce(lambda acc, x: acc if acc > x else x, numbers)\n",
        "```\n",
        "\n",
        "The reduce pattern here:\n",
        "- Start with first element as accumulator: `3`\n",
        "- For each item: keep the larger of `accumulator` vs `current_item`\n",
        "- Builds up: `max(3,1)=3`, then `max(3,4)=4`, then `max(4,1)=4`, then `max(4,5)=5`, etc.\n",
        "\n",
        "Now translate **both versions** to Elixir:\n",
        "1. Find the Elixir equivalent of Python's `max()`\n",
        "2. Write the explicit reduce version\n",
        "\n",
        "Try it out!\n",
        "\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "Hmmm. I am stuck as I don't know how to do if-else inside that anon function block\n",
        "```elixir\n",
        "iex(45)> Enum.max(numbers)\n",
        "5\n",
        "iex(46)> Enum.reduce(numbers, fn x, acc -> if x > acc then x else acc end)\n",
        "** (SyntaxError) invalid syntax found on iex:46:53:\n",
        "    error: syntax error before: 'else'\n",
        "iex(46)> Enum.reduce(numbers, fn x, acc -> if x > acc do  x else acc end)\n",
        "** (MismatchedDelimiterError) mismatched delimiter found on iex:46:64:\n",
        "    error: unexpected token: )\n",
        "```\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Good catch! You're running into Elixir's `if` syntax inside anonymous functions. The issue is that Elixir's `if` statement needs `do...end` blocks, but that doesn't work cleanly inside the compact `fn...end` syntax.\n",
        "\n",
        "Here are two solutions:\n",
        "\n",
        "**Solution 1: Use `max/2` function (simplest)**\n",
        "```elixir\n",
        "Enum.reduce(numbers, fn x, acc -> max(x, acc) end)\n",
        "```\n",
        "\n",
        "**Solution 2: Multi-line anonymous function (if you want the explicit if/else)**\n",
        "```elixir\n",
        "Enum.reduce(numbers, fn x, acc ->\n",
        "  if x > acc do\n",
        "    x\n",
        "  else\n",
        "    acc\n",
        "  end\n",
        "end)\n",
        "```\n",
        "\n",
        "The first solution is much cleaner and more idiomatic. Elixir has a built-in `max/2` function that takes two arguments and returns the larger one - perfect for reduce operations!\n",
        "\n",
        "Try the first solution - it should work perfectly and give you `9` as the result.\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "Great. I was thinking that there might be a max in Elixir. Then I thought that it would be inside Enum module - so, how I do write Enum.max by calling Enum.max inside it :) - So, I lost that line of thought. So, I was able to make it work - but what is this curious max function which does not seem to follow the Elixir convention of Module.function? \n",
        "```elixir\n",
        "Enum.reduce(numbers, fn x, acc -> max(x, acc) end)\n",
        "```\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Excellent observation! You've discovered something important about Elixir's design.\n",
        "\n",
        "The `max/2` function you used is actually part of Elixir's **Kernel module**. The Kernel module contains the most fundamental functions that are so commonly used they're automatically imported into every Elixir program.\n",
        "\n",
        "So when you write `max(x, acc)`, you're actually calling `Kernel.max(x, acc)`, but Elixir imports it automatically so you don't need the module prefix.\n",
        "\n",
        "**Other examples of auto-imported Kernel functions:**\n",
        "```elixir\n",
        "# These are all actually Kernel.function_name\n",
        "length([1, 2, 3])     # Really: Kernel.length/1\n",
        "abs(-5)               # Really: Kernel.abs/1  \n",
        "round(3.7)            # Really: Kernel.round/1\n",
        "min(5, 3)             # Really: Kernel.min/2\n",
        "```\n",
        "\n",
        "You can verify this by trying:\n",
        "```elixir\n",
        "Kernel.max(5, 3)  # This works too!\n",
        "```\n",
        "\n",
        "**Why the distinction?**\n",
        "- `Enum.max/1` - finds the maximum value **in a collection**\n",
        "- `Kernel.max/2` - finds the maximum **between two values**\n",
        "\n",
        "So `Enum.max([3, 1, 4, 1, 5, 9, 2])` and `Kernel.max(5, 3)` serve different purposes, which is why both exist!\n",
        "\n",
        "This is why your reduce solution works perfectly - you're using the two-argument version inside the reduction.\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "that is very nice and very interesting - So, there is direct equivalent for max and len functions in python here in Elixir. Great let us move on to the last reduce example.\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Exactly! Elixir does provide direct equivalents for many common Python functions, just organized differently:\n",
        "\n",
        "- Python `len()` → Elixir `length()` (auto-imported from Kernel)\n",
        "- Python `max()` → Elixir `max()` (auto-imported from Kernel) \n",
        "- Python `abs()` → Elixir `abs()` (auto-imported from Kernel)\n",
        "\n",
        "Now let's tackle the final reduce example - joining strings!\n",
        "\n",
        "**Python - Easy way (built-in method):**\n",
        "```python\n",
        "words = [\"Hello\", \"beautiful\", \"world\"]\n",
        "\", \".join(words)  # Result: \"Hello, beautiful, world\"\n",
        "```\n",
        "\n",
        "**Python - Reduce way (shows the pattern):**\n",
        "```python\n",
        "from functools import reduce\n",
        "words = [\"Hello\", \"beautiful\", \"world\"]\n",
        "reduce(lambda acc, x: acc + \", \" + x, words)  # Result: \"Hello, beautiful, world\"\n",
        "```\n",
        "\n",
        "The reduce pattern here:\n",
        "- Start with first element as accumulator: `\"Hello\"`\n",
        "- For each remaining item: combine `accumulator + \", \" + current_item`\n",
        "- Builds up: `\"Hello\" + \", \" + \"beautiful\" = \"Hello, beautiful\"`, then `\"Hello, beautiful\" + \", \" + \"world\" = \"Hello, beautiful, world\"`\n",
        "\n",
        "Now translate **both versions** to Elixir:\n",
        "1. Find the Elixir equivalent of Python's `\", \".join()`\n",
        "2. Write the explicit reduce version using string concatenation\n",
        "\n",
        "Try it out!\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "I translated the easy version. But I need some clues as `+` does not seem to work in Elixir for string concat - Hmmm. python was so much more intuitive. \n",
        "```elixir\n",
        "iex(47)> words = [\"Hello\", \"beautiful\", \"world\"]\n",
        "[\"Hello\", \"beautiful\", \"world\"]\n",
        "iex(51)> Enum.join(words, \", \")\n",
        "\"Hello, beautiful, world\"\n",
        "iex(52)> Enum.reduce(words, fn x, acc  -> acc + x end)\n",
        "** (ArithmeticError) bad argument in arithmetic expression: \"Hello\" + \"beautiful\"\n",
        "    :erlang.+(\"Hello\", \"beautiful\")\n",
        "    iex:52: (file)\n",
        "    iex:52: (file)\n",
        "```\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Great job finding `Enum.join(words, \", \")`! \n",
        "\n",
        "You're right that `+` doesn't work for string concatenation in Elixir - that's reserved for arithmetic. For strings, Elixir uses the `<>` operator:\n",
        "\n",
        "```elixir\n",
        "\"Hello\" <> \" \" <> \"world\"  # Result: \"Hello world\"\n",
        "```\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "Yes it is working for me. \n",
        "```elixir\n",
        "iex(52)> Enum.reduce(words, fn x, acc  -> acc <>  x end)\n",
        "\"Hellobeautifulworld\"\n",
        "iex(53)> Enum.reduce(words, fn x, acc  -> acc <> \",\" <>  x end)\n",
        "\"Hello,beautiful,world\"\n",
        "iex(54)> Enum.reduce(words, fn x, acc  -> acc <> \", \" <>  x end)\n",
        "\"Hello, beautiful, world\"\n",
        "```\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Perfect! You figured out the string concatenation operator `<>` and got it working.\n",
        "\n",
        "I can see your thought process in those three attempts:\n",
        "1. `acc <> x` → `\"Hellobeautifulworld\"` (no separator)\n",
        "2. `acc <> \",\" <> x` → `\"Hello,beautiful,world\"` (comma but no space)\n",
        "3. `acc <> \", \" <> x` → `\"Hello, beautiful, world\"` (perfect!)\n",
        "\n",
        "## Reduce Pattern Summary ✅ **COMPLETED**\n",
        "\n",
        "You've now mastered all three examples:\n",
        "\n",
        "**Convenient shortcuts:**\n",
        "- `Enum.sum(numbers)` \n",
        "- `Enum.max(numbers)`\n",
        "- `Enum.join(words, \", \")`\n",
        "\n",
        "**Explicit reduce patterns:**\n",
        "- `Enum.reduce(numbers, fn x, acc -> x + acc end)`\n",
        "- `Enum.reduce(numbers, fn x, acc -> max(x, acc) end)`\n",
        "- `Enum.reduce(words, fn x, acc -> acc <> \", \" <> x end)`\n",
        "\n",
        "## 🎉 All Three Functional Patterns Complete!\n",
        "\n",
        "You've mastered:\n",
        "- **MAP**: Transform each item → `Enum.map`\n",
        "- **FILTER**: Keep only some items → `Enum.filter` \n",
        "- **REDUCE**: Combine all into one result → `Enum.reduce`\n",
        "\n",
        "These three patterns handle 90% of all data processing tasks you'll encounter. Ready to put it all together with **piping**?\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "That is great - let us summarize the 3 core functional patterns first and make sure that I understand them well by giving me 3 exercises which combines these ideas together.\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "## Summary: The 3 Core Functional Patterns\n",
        "\n",
        "### **MAP** - Transform Each Item\n",
        "**Pattern:** Same number of items out as in, but transformed\n",
        "**Syntax:** `Enum.map(collection, fn item -> transformation end)`\n",
        "**Examples:**\n",
        "- Uppercase strings: `Enum.map(words, fn x -> String.upcase(x) end)`\n",
        "- Add tax: `Enum.map(prices, fn x -> x * 1.08 end)`\n",
        "- Get lengths: `Enum.map(words, fn x -> String.length(x) end)`\n",
        "\n",
        "### **FILTER** - Keep Only Some Items\n",
        "**Pattern:** Fewer (or same) items out, but same values\n",
        "**Syntax:** `Enum.filter(collection, fn item -> boolean_condition end)`\n",
        "**Examples:**\n",
        "- Long words: `Enum.filter(words, fn x -> String.length(x) > 5 end)`\n",
        "- Positive numbers: `Enum.filter(numbers, fn x -> x > 0 end)`\n",
        "- Starts with \"a\": `Enum.filter(fruits, fn x -> String.starts_with?(x, \"a\") end)`\n",
        "\n",
        "### **REDUCE** - Combine All Into One Result\n",
        "**Pattern:** Single result from entire collection\n",
        "**Syntax:** `Enum.reduce(collection, fn item, accumulator -> combination end)`\n",
        "**Examples:**\n",
        "- Sum: `Enum.reduce(numbers, fn x, acc -> x + acc end)` or `Enum.sum(numbers)`\n",
        "- Max: `Enum.reduce(numbers, fn x, acc -> max(x, acc) end)` or `Enum.max(numbers)`\n",
        "- Join: `Enum.reduce(words, fn x, acc -> acc <> \", \" <> x end)` or `Enum.join(words, \", \")`\n",
        "\n",
        "---\n",
        "\n",
        "## 3 Exercises combining map, filter and reduce\n",
        "\n",
        "Let us start with a straightforward exercise. \n",
        "\n",
        "**Exercise 1: Word Processing Pipeline**\n",
        "```python\n",
        "words = [\"apple\", \"BANANA\", \"Cherry\", \"date\", \"ELDERBERRY\"]\n",
        "# 1. Convert all to lowercase\n",
        "# 2. Keep only words with more than 4 letters  \n",
        "# 3. Count how many words remain\n",
        "# Expected result: 4 \n",
        "# they are [\"apple\", \"banana\", \"cherry\", \"elderberry\"]\n",
        "```\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "yes it was easy\n",
        "```elixir\n",
        "iex(56)> words = [\"apple\", \"BANANA\", \"Cherry\", \"date\", \"ELDERBERRY\"]\n",
        "[\"apple\", \"BANANA\", \"Cherry\", \"date\", \"ELDERBERRY\"]\n",
        "iex(57)> words = Enum.map(words, fn x -> String.downcase(x) end)\n",
        "[\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\"]\n",
        "iex(58)> words = Enum.filter(words, fn x -> String.length(x) > 4 end)\n",
        "[\"apple\", \"banana\", \"cherry\", \"elderberry\"]\n",
        "iex(59)> length(words)\n",
        "4\n",
        "```\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Excellent work! You correctly applied all three patterns in sequence:\n",
        "\n",
        "✅ **MAP**: `String.downcase(x)` to convert to lowercase  \n",
        "✅ **FILTER**: `String.length(x) > 4` to keep long words  \n",
        "✅ **REDUCE**: `length(words)` to count the results  \n",
        "\n",
        "Your step-by-step approach with intermediate variables is perfect for learning. You can see exactly what happens at each stage:\n",
        "1. Mixed case → all lowercase\n",
        "2. 5 words → 4 words (filtered out \"date\")\n",
        "3. List → count of 4\n",
        "\n",
        "**Exercise 2: Number Crunching Pipeline**\n",
        "```elixir\n",
        "numbers = [1, -2, 3, -4, 5, -6, 7, 8, -9, 10]\n",
        "# 1. Keep only positive numbers\n",
        "# 2. Square each number  \n",
        "# 3. Sum all the squares\n",
        "# Expected result: 248\n",
        "```\n",
        "\n",
        "So the expected result is **248**. Give this one a try!\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "I got it - I really like the simple touch of Elixir - it returns the right-hand side after pattern-matching which helps me to immediately see the output in a REPL session like this - I love this.\n",
        "\n",
        "```elixir\n",
        "iex(61)> numbers = [1, -2, 3, -4, 5, -6, 7, 8, -9, 10]\n",
        "[1, -2, 3, -4, 5, -6, 7, 8, -9, 10]\n",
        "iex(61)> numbers = Enum.filter(numbers, fn x -> x > 0 end)\n",
        "[1, 3, 5, 7, 8, 10]\n",
        "iex(62)> numbers = Enum.map(numbers, fn x -> x * x end)\n",
        "[1, 9, 25, 49, 64, 100]\n",
        "iex(63)> Enum.sum(numbers)\n",
        "248\n",
        "```\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Perfect! You nailed it exactly right. I love your observation about Elixir returning the right-hand side value - it really does make REPL-driven development so much more pleasant compared to Python where you often have to print or re-type variable names to see results.\n",
        "\n",
        "Your pipeline was flawless:\n",
        "✅ **FILTER**: `x > 0` kept `[1, 3, 5, 7, 8, 10]`  \n",
        "✅ **MAP**: `x * x` squared them to `[1, 9, 25, 49, 64, 100]`  \n",
        "✅ **REDUCE**: `Enum.sum` gave you `248`\n",
        "\n",
        "**Final Exercise 3: String Analysis Pipeline**\n",
        "```elixir\n",
        "sentences = [\"Hello world\", \"Elixir is fun\", \"I love programming\", \"Code every day\"]\n",
        "# 1. Split each sentence into words (hint: String.split)\n",
        "# 2. Flatten the result into one big list of words  \n",
        "# 3. Filter out words shorter than 4 characters\n",
        "# 4. Count the remaining words\n",
        "# Expected result: 7\n",
        "```\n",
        "\n",
        "This one introduces a new challenge - you'll need to look up `String.split/1` and figure out how to flatten a list of lists into a single list. Try exploring the `List` module for a flatten function!\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "Yes - it felt a bit uneasy as I was not sure how to flatten the list of lists. But I got it - I was able to find `List.flatten/1` function. \n",
        "```elixir\n",
        "iex(67)> sentences = Enum.map(sentences, fn x -> String.split(x) end)\n",
        "[\n",
        "  [\"Hello\", \"world\"],\n",
        "  [\"Elixir\", \"is\", \"fun\"],\n",
        "  [\"I\", \"love\", \"programming\"],\n",
        "  [\"Code\", \"every\", \"day\"]\n",
        "]\n",
        "iex(73)> words = Enum.filter(words, fn x -> String.length(x) >= 4 end)\n",
        "[\"Hello\", \"world\", \"Elixir\", \"love\", \"programming\", \"Code\", \"every\"]\n",
        "iex(74)> length(words)\n",
        "7\n",
        "```\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Great work! You successfully found `List.flatten/1` and applied the pipeline. I can see you got 7 words instead of the expected 6, but let me check your logic...\n",
        "\n",
        "Looking at your final filtered list: `[\"Hello\", \"world\", \"Elixir\", \"love\", \"programming\", \"Code\", \"every\"]`\n",
        "\n",
        "You used `>= 4` (4 or more characters), since exercise asked for filtering out words \"shorter than 4 characters\", which means keeping words with 4 or more characters - so your logic is actually correct!\n",
        "\n",
        "Your pipeline is perfect:\n",
        "\n",
        "✅ **MAP**: `String.split(x)` to split sentences into word lists  \n",
        "✅ **FLATTEN**: `List.flatten()` to combine into single word list  \n",
        "✅ **FILTER**: `String.length(x) >= 4` to keep long words  \n",
        "✅ **COUNT**: `length()` to get final count of 7\n",
        "\n",
        "Excellent problem-solving finding the flatten function! Ready to learn how to make these pipelines even more elegant with the pipe operator?\n",
        "\n",
        "# Piping in Elixir - Joy of reading from left to right\n",
        "\n",
        "## The Problem: Nested Function Hell\n",
        "\n",
        "Imagine you're making a sandwich. Here's how you'd naturally describe the process:\n",
        "\n",
        "1. Get the bread\n",
        "2. Toast the bread\n",
        "3. Add cheese\n",
        "4. Add lettuce\n",
        "5. Add mayo\n",
        "\n",
        "But in most programming languages, you'd have to write it backwards or create a mess of nested functions.\n",
        "\n",
        "## Python's Approach (Reading Inside-Out)\n",
        "\n",
        "**Python with nested functions:**\n",
        "\n",
        "```python\n",
        "def make_sandwich():\n",
        "    return add_mayo(add_lettuce(\n",
        "        add_cheese(toast_bread(get_bread()))))\n",
        "\n",
        "# This reads inside-out: confusing!\n",
        "# You have to start from get_bread() and work your way out\n",
        "```\n",
        "\n",
        "**Python with intermediate variables:**\n",
        "\n",
        "```python\n",
        "def make_sandwich():\n",
        "    bread = get_bread()\n",
        "    toasted = toast_bread(bread)\n",
        "    with_cheese = add_cheese(toasted)\n",
        "    with_lettuce = add_lettuce(with_cheese)\n",
        "    final = add_mayo(with_lettuce)\n",
        "    return final\n",
        "\n",
        "# Better, but lots of temporary variables\n",
        "```\n",
        "\n",
        "## Elixir's Solution: The Pipe Operator `|>`\n",
        "\n",
        "**Elixir with piping:**\n",
        "\n",
        "```elixir\n",
        "def make_sandwich do\n",
        "  get_bread()\n",
        "  |> toast_bread()\n",
        "  |> add_cheese()\n",
        "  |> add_lettuce()\n",
        "  |> add_mayo()\n",
        "end\n",
        "```\n",
        "\n",
        "This reads **exactly like your recipe instructions** - top to bottom, step by step!\n",
        "\n",
        "## How the Pipe Operator Works\n",
        "\n",
        "The pipe operator `|>` takes the result from the left side and passes it as the **first argument** to the function on the right side.\n",
        "\n",
        "**These are equivalent:**\n",
        "\n",
        "```elixir\n",
        "# With pipe\n",
        "name |> String.upcase()\n",
        "\n",
        "# Without pipe  \n",
        "String.upcase(name)\n",
        "```\n",
        "\n",
        "**Longer chain:**\n",
        "\n",
        "```elixir\n",
        "# With pipe\n",
        "\"  hello world  \"\n",
        "|> String.trim()\n",
        "|> String.upcase()\n",
        "|> String.reverse()\n",
        "\n",
        "# Without pipe (nested mess)\n",
        "String.reverse(String.upcase(String.trim(\"  hello world  \")))\n",
        "\n",
        "# Step by step what happens:\n",
        "# Step 1: \"  hello world  \" |> String.trim() → \"hello world\"\n",
        "# Step 2: \"hello world\" |> String.upcase() → \"HELLO WORLD\"  \n",
        "# Step 3: \"HELLO WORLD\" |> String.reverse() → \"DLROW OLLEH\"\n",
        "```\n",
        "\n",
        "## Real Example: Processing a Name\n",
        "\n",
        "Let's say you want to clean up and format a user's name input.\n",
        "\n",
        "**Python approach:**\n",
        "\n",
        "```python\n",
        "def clean_name(raw_name):\n",
        "    return raw_name.strip().title()\n",
        "\n",
        "name = \"  alice johnson  \"\n",
        "result = clean_name(name)\n",
        "print(result)  # \"Alice Johnson\"\n",
        "```\n",
        "\n",
        "**Elixir with piping:**\n",
        "\n",
        "```elixir\n",
        "def clean_name(raw_name) do\n",
        "  raw_name\n",
        "  |> String.trim()\n",
        "  |> String.capitalize()\n",
        "end\n",
        "\n",
        "name = \"  alice johnson  \"\n",
        "result = clean_name(name)\n",
        "IO.puts(result)  # \"Alice Johnson\"\n",
        "```\n",
        "\n",
        "## More Complex Example: Building a Greeting\n",
        "\n",
        "**Python (multiple steps):**\n",
        "\n",
        "```python\n",
        "def create_greeting(name, title):\n",
        "    cleaned = name.strip().title()\n",
        "    formal = f\"{title} {cleaned}\"\n",
        "    return f\"Welcome, {formal}!\"\n",
        "\n",
        "greeting = create_greeting(\"  bob smith  \", \"Dr.\")\n",
        "print(greeting)  # \"Welcome, Dr. Bob Smith!\"\n",
        "```\n",
        "\n",
        "**Elixir (reads like a recipe):**\n",
        "`then/2` takes the piped value and passes it as an argument to an anonymous function. The syntax is:\n",
        "\n",
        "```elixir\n",
        "value |> then(fn x -> # do something with x end)\n",
        "```\n",
        "\n",
        "Now here is the pipeline version of create_greeting: \n",
        "\n",
        "```elixir\n",
        "def create_greeting(name, title) do\n",
        "  name\n",
        "  |> String.trim()           # Remove whitespace\n",
        "  |> String.capitalize()     # Capitalize properly\n",
        "  |> then(fn clean_name -> \"#{title} #{clean_name}\" end)  # Add title\n",
        "  |> then(fn formal -> \"Welcome, #{formal}!\" end)         # Add welcome\n",
        "end\n",
        "\n",
        "greeting = create_greeting(\"  bob smith  \", \"Dr.\")\n",
        "IO.puts(greeting)  # \"Welcome, Dr. Bob Smith!\"\n",
        "```\n",
        "\n",
        "## The Magic: Debugging Made Easy\n",
        "\n",
        "Want to see what's happening at each step? Just add `|> IO.inspect()`:\n",
        "\n",
        "```elixir\n",
        "\"  alice johnson  \"\n",
        "|> IO.inspect()     # Prints: \"  alice johnson  \"\n",
        "|> String.trim()\n",
        "|> IO.inspect(label: \"After trim\")   # Prints: After trim: \"alice johnson\"\n",
        "|> String.capitalize()\n",
        "|> IO.inspect(label: \"Final\")        # Prints: Final: \"Alice Johnson\"\n",
        "```\n",
        "\n",
        "This is **impossible** to do cleanly with nested functions!\n",
        "\n",
        "## Why Piping is Elegant\n",
        "\n",
        "**Mental Model: Assembly Line**\n",
        "\n",
        "- Each function is a **station** on an assembly line\n",
        "- Data flows **left to right**, **top to bottom**\n",
        "- Each step **transforms** the data and passes it to the next step\n",
        "- Easy to **add**, **remove**, or **reorder** steps\n",
        "\n",
        "**Benefits:**\n",
        "\n",
        "1. **Readable**: Reads like step-by-step instructions\n",
        "2. **Debuggable**: Easy to inspect data at any point\n",
        "3. **Modular**: Easy to add/remove transformations\n",
        "4. **No Nesting**: No confusing inside-out reading\n",
        "5. **Natural Flow**: Matches how you think about the problem\n",
        "\n",
        "## Key Takeaway\n",
        "\n",
        "The pipe operator `|>` transforms your code from a **puzzle of nested function calls** into a **clear sequence of transformations**.\n",
        "\n",
        "Instead of reading inside-out, you read top-to-bottom, just like following a recipe or assembly line instructions.\n",
        "\n",
        "**Remember**: `data |> function()` is the same as `function(data)` - the pipe just makes the data flow more obvious and readable.\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "That is a wonderful detour.  I guess that these 3 exercises with all these intermediate variables will become more elegant with the pipe operator.\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Exactly! You've hit the nail on the head. All those intermediate variables (`words = Enum.map(words, ...)`, `words = Enum.filter(words, ...)`) are exactly what the pipe operator eliminates.\n",
        "\n",
        "Let's transform your Exercise 1 solution to see the magic:\n",
        "\n",
        "**Your current approach (with intermediate variables):**\n",
        "```elixir\n",
        "words = [\"apple\", \"BANANA\", \"Cherry\", \"date\", \"ELDERBERRY\"]\n",
        "words = Enum.map(words, fn x -> String.downcase(x) end)\n",
        "words = Enum.filter(words, fn x -> String.length(x) > 4 end)\n",
        "length(words)\n",
        "```\n",
        "\n",
        "**With the pipe operator:**\n",
        "```elixir\n",
        "[\"apple\", \"BANANA\", \"Cherry\", \"date\", \"ELDERBERRY\"]\n",
        "|> Enum.map(fn x -> String.downcase(x) end)\n",
        "|> Enum.filter(fn x -> String.length(x) > 4 end)\n",
        "|> length()\n",
        "```\n",
        "\n",
        "The `|>` operator takes the result from the left side and passes it as the **first argument** to the function on the right side.\n",
        "\n",
        "Try this transformation yourself with Exercise 1.\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "this is beautiful. I just copied and pasted your code into iex and iex somehow intuitively picked up the result of the previous expression and passed it to pipe\n",
        "```elixir\n",
        "iex(81)> [\"apple\", \"BANANA\", \"Cherry\", \"date\", \"ELDERBERRY\"]\n",
        "[\"apple\", \"BANANA\", \"Cherry\", \"date\", \"ELDERBERRY\"]\n",
        "iex(82)> |> Enum.map(fn x -> String.downcase(x) end)\n",
        "[\"apple\", \"banana\", \"cherry\", \"date\", \"elderberry\"]\n",
        "iex(83)> |> Enum.filter(fn x -> String.length(x) > 4 end)\n",
        "[\"apple\", \"banana\", \"cherry\", \"elderberry\"]\n",
        "iex(84)> |> length()\n",
        "4\n",
        "```\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Wow! That's incredible - you've discovered one of the most delightful features of IEx! \n",
        "\n",
        "Yes, IEx is smart enough to automatically pipe the result of the previous expression when you start a new line with `|>`. This makes interactive development absolutely magical - you can build up complex transformations step by step, seeing the result at each stage.\n",
        "\n",
        "This is **exactly** how experienced Elixir developers work:\n",
        "1. Start with some data\n",
        "2. Pipe it through one transformation\n",
        "3. See the result, make sure it's what you expect\n",
        "4. Add the next pipe\n",
        "5. Keep building the pipeline incrementally\n",
        "\n",
        "You can also write it all as one expression:\n",
        "```elixir\n",
        "[\"apple\", \"BANANA\", \"Cherry\", \"date\", \"ELDERBERRY\"]\n",
        "|> Enum.map(fn x -> String.downcase(x) end)\n",
        "|> Enum.filter(fn x -> String.length(x) > 4 end)\n",
        "|> length()\n",
        "```\n",
        "\n",
        "But the interactive approach you just discovered is often better for development because you can verify each step!\n",
        "\n",
        "Try converting your Exercise 2 solution using pipes now. You'll love how it reads like a recipe: \"Take numbers, then filter positives, then square them, then sum them up.\"\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "can you please recall the code I used for exercise 2?\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Of course! Here's your Exercise 2 solution:\n",
        "\n",
        "```elixir\n",
        "numbers = [1, -2, 3, -4, 5, -6, 7, 8, -9, 10]\n",
        "numbers = Enum.filter(numbers, fn x -> x > 0 end)\n",
        "numbers = Enum.map(numbers, fn x -> x * x end)\n",
        "Enum.sum(numbers)\n",
        "```\n",
        "\n",
        "Now try converting this to use the pipe operator! Start with the initial list and pipe it through each transformation step by step.\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "Great - this definitely feels better and easier. I loved the flexibility to drop the parantheses for Enum.sum. \n",
        "\n",
        "```elixir\n",
        "iex(85)> [1, -2, 3, -4, 5, -6, 7, 8, -9, 10]\n",
        "[1, -2, 3, -4, 5, -6, 7, 8, -9, 10]\n",
        "iex(86)> |> Enum.filter(fn x -> x > 0 end)\n",
        "[1, 3, 5, 7, 8, 10]\n",
        "iex(87)> |> Enum.map(fn x -> x * x end)\n",
        "[1, 9, 25, 49, 64, 100]\n",
        "iex(88)> |> Enum.sum\n",
        "248\n",
        "\n",
        "```\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Perfect! You've really got the hang of this. I love how you noticed the flexibility with parentheses - `|> Enum.sum` is so clean and readable.\n",
        "\n",
        "The pipeline now reads like natural language:\n",
        "- \"Take these numbers\"\n",
        "- \"Filter to keep positive ones\" \n",
        "- \"Map each to its square\"\n",
        "- \"Sum them all up\"\n",
        "\n",
        "This is exactly why Elixir developers love the pipe operator - it transforms nested function calls into a clear, step-by-step recipe.\n",
        "\n",
        "Now try Exercise 3 with pipes! That one had 4 steps:\n",
        "\n",
        "Your original solution was:\n",
        "```elixir\n",
        "sentences = [\"Hello world\", \"Elixir is fun\", \"I love programming\", \"Code every day\"]\n",
        "sentences = Enum.map(sentences, fn x -> String.split(x) end)\n",
        "words = List.flatten(sentences)\n",
        "words = Enum.filter(words, fn x -> String.length(x) >= 4 end)\n",
        "length(words)\n",
        "```\n",
        "\n",
        "Can you convert this to a beautiful pipeline?\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "Yes I have done it, But I tried to use the shorter syntax for anon functions, but one place, I got an error which perplexed me - take a look. \n",
        "```elixir\n",
        "iex(89)> [\"Hello world\", \"Elixir is fun\", \"I love programming\", \"Code every day\"]\n",
        "[\"Hello world\", \"Elixir is fun\", \"I love programming\", \"Code every day\"]\n",
        "iex(90)> |> Enum.map(&String.split/2)\n",
        "** (BadArityError) &String.split/2 with arity 2 called with 1 argument (\"Hello world\")\n",
        "    (elixir 1.18.3) lib/enum.ex:1714: Enum.\"-map/2-lists^map/1-1-\"/2\n",
        "    iex:90: (file)\n",
        "iex(90)> |> Enum.map(&String.split/1)\n",
        "[\n",
        "  [\"Hello\", \"world\"],\n",
        "  [\"Elixir\", \"is\", \"fun\"],\n",
        "  [\"I\", \"love\", \"programming\"],\n",
        "  [\"Code\", \"every\", \"day\"]\n",
        "]\n",
        "iex(91)> |> List.flatten\n",
        "[\"Hello\", \"world\", \"Elixir\", \"is\", \"fun\", \"I\", \"love\", \"programming\", \"Code\",\n",
        " \"every\", \"day\"]\n",
        "iex(92)> |> Enum.filter(&(String.length(&1) >=4))\n",
        "[\"Hello\", \"world\", \"Elixir\", \"love\", \"programming\", \"Code\", \"every\"]\n",
        "iex(93)> |> length\n",
        "7\n",
        "```\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Great work! You successfully converted it to a beautiful pipeline. Your error discovery is actually a fantastic learning moment!\n",
        "\n",
        "## The String.split Arity Issue\n",
        "\n",
        "You discovered something important about `String.split`:\n",
        "\n",
        "- `String.split/1` - splits on whitespace (what you wanted)\n",
        "- `String.split/2` - splits on a specific pattern (takes string + pattern)\n",
        "\n",
        "When you used `&String.split/2`, Elixir expected you to provide 2 arguments, but `Enum.map` only provides 1 (the string from the list). That's why you got the \"called with 1 argument\" error.\n",
        "\n",
        "## The Capture Operator Complexity\n",
        "\n",
        "Notice how your filter line got a bit messy:\n",
        "```elixir\n",
        "|> Enum.filter(&(String.length(&1) >= 4))\n",
        "```\n",
        "\n",
        "This is where the capture operator starts to feel clunky. Compare:\n",
        "```elixir\n",
        "# Capture operator (harder to read)\n",
        "|> Enum.filter(&(String.length(&1) >= 4))\n",
        "\n",
        "# Regular anonymous function (clearer)\n",
        "|> Enum.filter(fn x -> String.length(x) >= 4 end)\n",
        "```\n",
        "\n",
        "For simple function calls like `&String.split/1`, the capture operator is great. But for complex expressions, the regular `fn` syntax is often more readable.\n",
        "\n",
        "Your final pipeline is beautiful - it reads like a story from top to bottom!\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "ok great - can you please summarize pipe operator and is there anything else to know about piping syntax in Elixir?\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "## Pipe Operator Summary\n",
        "\n",
        "### **Basic Concept**\n",
        "The pipe operator `|>` takes the result from the left and passes it as the **first argument** to the function on the right.\n",
        "\n",
        "```elixir\n",
        "data |> function(args)  # Same as: function(data, args)\n",
        "```\n",
        "\n",
        "### **Key Benefits**\n",
        "✅ **Readable**: Top-to-bottom flow like a recipe  \n",
        "✅ **Debuggable**: Easy to inspect at each step with `|> IO.inspect()`  \n",
        "✅ **Modular**: Easy to add/remove/reorder steps  \n",
        "✅ **No nesting**: Eliminates confusing inside-out reading  \n",
        "✅ **REPL-friendly**: IEx auto-pipes when you start with `|>`  \n",
        "\n",
        "### **When to Use Pipes vs Regular Syntax**\n",
        "```elixir\n",
        "# Good for pipes - simple transformations\n",
        "data |> String.upcase() |> String.reverse()\n",
        "\n",
        "# Better without pipes - single function call\n",
        "String.upcase(data)\n",
        "\n",
        "# Good for pipes - multiple steps\n",
        "numbers |> Enum.filter(&(&1 > 0)) |> Enum.sum()\n",
        "```\n",
        "\n",
        "## Advanced Piping Features\n",
        "\n",
        "### **1. The `then/2` Function**\n",
        "When you need to use the piped value in a complex expression:\n",
        "```elixir\n",
        "name\n",
        "|> String.trim()\n",
        "|> then(fn clean_name -> \"Hello, #{clean_name}!\" end)\n",
        "```\n",
        "\n",
        "### **2. Debugging with IO.inspect**\n",
        "```elixir\n",
        "data\n",
        "|> transform_step_1()\n",
        "|> IO.inspect(label: \"After step 1\")  # Prints and passes through\n",
        "|> transform_step_2()\n",
        "|> IO.inspect()  # Quick peek\n",
        "```\n",
        "\n",
        "### **3. Parentheses Rules in Pipes**\n",
        "```elixir\n",
        "# Optional parentheses (clean)\n",
        "data |> String.upcase |> String.reverse\n",
        "\n",
        "# Required for zero-argument functions\n",
        "data |> String.trim() |> System.system_time()\n",
        "\n",
        "# Required for clarity with multiple arguments  \n",
        "data |> String.replace(\"old\", \"new\")\n",
        "```\n",
        "\n",
        "That covers the essential piping knowledge! The pipe operator is one of Elixir's most beloved features.\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "Ok, I think that we have covered 3 key ideas that we started with - pattern matching, immutability and piping - can you please summarise?\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "## Summary: The 3 Core Elixir Concepts\n",
        "\n",
        "### **1. Pattern Matching** ✅\n",
        "**Concept**: `=` is a match operator (bidirectional equality), not assignment\n",
        "```elixir\n",
        "[a, b, c] = [1, 2, 3]        # Explicit structure matching\n",
        "[head | tail] = [1, 2, 3]    # Head/tail decomposition\n",
        "6 = 5 + 1                    # Bidirectional - works both ways!\n",
        "```\n",
        "**Benefits**: Data validation, concise destructuring, less error-checking code\n",
        "\n",
        "### **2. Immutability** ✅\n",
        "**Concept**: Data never changes after creation - functions return new data\n",
        "```elixir\n",
        "list = [1, 2, 3]\n",
        "new_list = [0 | list]        # Creates new list, original unchanged\n",
        "# list is still [1, 2, 3]\n",
        "```\n",
        "**Benefits**: No surprise mutations, safe sharing, easier debugging, memory-efficient through structural sharing\n",
        "\n",
        "### **3. Piping** ✅\n",
        "**Concept**: `|>` passes result as first argument to next function\n",
        "```elixir\n",
        "data\n",
        "|> transform_step_1()\n",
        "|> transform_step_2()\n",
        "|> final_result()\n",
        "```\n",
        "**Benefits**: Readable top-to-bottom flow, easy debugging, modular transformations\n",
        "\n",
        "## **The 3 Functional Patterns** ✅\n",
        "- **MAP**: Transform each item → `Enum.map`\n",
        "- **FILTER**: Keep only some items → `Enum.filter`  \n",
        "- **REDUCE**: Combine all into one → `Enum.reduce`\n",
        "\n",
        "## **How They Work Together**\n",
        "```elixir\n",
        "[\"Apple\", \"BANANA\", \"cherry\"]\n",
        "|> Enum.map(&String.downcase/1)     # Transform each\n",
        "|> Enum.filter(&(String.length(&1) > 4))  # Keep some\n",
        "|> length()                         # Combine to count\n",
        "```\n",
        "\n",
        "These three concepts form the foundation of thinking functionally in Elixir!\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "ok what comes next?\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Great question! You've built a solid foundation in Elixir's core concepts. Here are the natural next steps:\n",
        "\n",
        "## **Immediate Next Steps**\n",
        "\n",
        "**1. Data Structures Beyond Lists**\n",
        "- **Tuples**: `{:ok, result}` - fixed-size, fast access\n",
        "- **Maps**: `%{name: \"Alice\", age: 30}` - key-value pairs (like Python dicts)\n",
        "- **Keyword Lists**: `[name: \"Alice\", age: 30]` - ordered key-value pairs\n",
        "\n",
        "**2. Control Flow**\n",
        "- **case** statements with pattern matching\n",
        "- **cond** for multiple conditions\n",
        "- **with** for happy path programming\n",
        "\n",
        "**3. Modules and Functions**\n",
        "- Defining your own modules\n",
        "- Named functions vs anonymous functions\n",
        "- Function clauses and guards\n",
        "\n",
        "## **Phoenix-Focused Path**\n",
        "\n",
        "Since your goal is to evaluate Phoenix vs Rails, you could also jump more directly into Phoenix fundamentals:\n",
        "\n",
        "**1. Basic Phoenix App**\n",
        "- Controllers, Views, Templates\n",
        "- Routing\n",
        "- LiveView basics\n",
        "\n",
        "**2. Database Integration**\n",
        "- Ecto (Elixir's database library)\n",
        "- Schemas and migrations\n",
        "\n",
        "What feels more appealing to you right now:\n",
        "- **A.** Continue building Elixir language skills with data structures and control flow?\n",
        "- **B.** Jump into a simple Phoenix application to see the web framework in action?\n",
        "- **C.** Something else you're curious about?\n",
        "\n",
        "Your learning style and timeline will help determine the best path!\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "i want to do a phoeix-focused path, but let us not jump into phoenix just yet. My aim is to generate a to-do list app or blog app at the end of the book and I should be able to read through the code and understand most of the things. So, what topics should be covered next?\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Perfect! Building toward a Phoenix to-do or blog app is an excellent goal. Let me map out the essential Elixir concepts you'll need to understand Phoenix code comfortably.\n",
        "\n",
        "## **Essential Elixir for Phoenix Development**\n",
        "\n",
        "### **Phase 1: Data Structures (Next)**\n",
        "You'll see these everywhere in Phoenix:\n",
        "- **Maps**: `%{title: \"Learn Elixir\", completed: false}` - your data models\n",
        "- **Tuples**: `{:ok, user}` vs `{:error, reason}` - Phoenix's return patterns\n",
        "- **Keyword Lists**: `[class: \"btn\", id: \"submit\"]` - HTML attributes\n",
        "\n",
        "### **Phase 2: Pattern Matching in Practice**\n",
        "- **case** statements - handling different outcomes\n",
        "- **with** statements - chaining operations that might fail\n",
        "- **Function clauses** - multiple function definitions with different patterns\n",
        "\n",
        "### **Phase 3: Modules and Functions**\n",
        "- Creating your own modules\n",
        "- Public vs private functions\n",
        "- How Phoenix organizes code into modules\n",
        "\n",
        "### **Phase 4: Error Handling**\n",
        "- `{:ok, result}` vs `{:error, reason}` pattern\n",
        "- How to handle failures gracefully\n",
        "\n",
        "### **Phase 5: Basic Phoenix Concepts**\n",
        "- Understanding MVC in Phoenix\n",
        "- How requests flow through the application\n",
        "- Templates and data binding\n",
        "\n",
        "This sequence will prepare you to read and understand Phoenix code naturally. Each concept builds on what you already know.\n",
        "\n",
        "**Ready to start with Maps and Tuples?** These are the data structures you'll use constantly in Phoenix apps.\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "## Maps\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "yes let us cover maps and see how they compare with python.\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "# Maps in Elixir vs Python\n",
        "\n",
        "Maps are key-value data structures that store associations between unique keys and their values. Python uses dictionaries while Elixir uses maps - here's how their syntax compares for common operations.\n",
        "\n",
        "## Creating Maps\n",
        "\n",
        "**Python:**\n",
        "```python\n",
        "person = {\"name\": \"Alice\", \"age\": 30, \"city\": \"New York\"}\n",
        "empty_dict = {}\n",
        "```\n",
        "\n",
        "**Elixir:**\n",
        "```elixir\n",
        "person = %{\"name\" => \"Alice\", \"age\" => 30, \"city\" => \"New York\"}\n",
        "\n",
        "# Though the above syntax is the default, Elixir provides a syntactic sugar which looks very close to python dictionary. \n",
        "# but you will discover that the space after the colon is required, unlike python :)\n",
        "atom_map = %{name: \"Alice\", age: 30, city: \"New York\"}  # atom keys - cleaner syntax\n",
        "\n",
        "# you might question the need for the `%` before the curly braces, Elixir uses curly braces alone for tuples. So, maps need that extra symbol `%`\n",
        "empty_map = %{}\n",
        "\n",
        "# These are identical:\n",
        "%{name: \"Alice\", age: 30}        # Shorthand syntax\n",
        "# this is converted to the following syntax - coming from python or JS, the above syntax is easier\n",
        "%{:name => \"Alice\", :age => 30}  # Explicit atom syntax\n",
        "```\n",
        "\n",
        "## Accessing Values\n",
        "\n",
        "**Python:**\n",
        "```python\n",
        "name = person[\"name\"]           # Raises KeyError if key doesn't exist\n",
        "age = person.get(\"age\", 0)      # Returns default value if missing\n",
        "```\n",
        "\n",
        "**Elixir:**\n",
        "```elixir\n",
        "# Returns nil if key doesn't exist. Thank God - no exceptions when keys are not found. It is a graceful nil. \n",
        "name = person[\"name\"]           \n",
        "age = Map.get(person, \"age\", 0) # Returns default value if missing\n",
        "\n",
        "# Atom keys enable dot notation:\n",
        "name = atom_map.name            # Raises KeyError if key doesn't exist\n",
        "name = atom_map[:name]          # Returns nil if key doesn't exist\n",
        "\n",
        "# Unlike Python where KeyError is always raised, Elixir gives you choice:\n",
        "# - Use dot notation when you expect the key to exist (fails fast)\n",
        "# - Use bracket notation when the key might be missing (returns nil)\n",
        "```\n",
        "\n",
        "## Adding/Updating Values\n",
        "\n",
        "**Python:**\n",
        "```python\n",
        "person[\"email\"] = \"alice@example.com\"  # Add new key\n",
        "person[\"age\"] = 31                     # Update existing key\n",
        "```\n",
        "\n",
        "**Elixir:**\n",
        "```elixir\n",
        "# Returns new map (immutable!)\n",
        "updated_person = Map.put(person, \"email\", \"alice@example.com\")  # Adds or updates key\n",
        "updated_person = %{person | \"age\" => 31}  # Update syntax - key must exist or raises KeyError\n",
        "\n",
        "# Different behaviors for adding vs updating:\n",
        "# Map.put/3 - always works (add or update)\n",
        "# | syntax - only for updating existing keys (safer, fails if key missing)\n",
        "```\n",
        "\n",
        "## Checking for Keys\n",
        "\n",
        "**Python:**\n",
        "```python\n",
        "if \"name\" in person:\n",
        "    print(person[\"name\"])\n",
        "```\n",
        "\n",
        "**Elixir:**\n",
        "```elixir\n",
        "if Map.has_key?(person, \"name\") do\n",
        "  IO.puts(person[\"name\"])\n",
        "end\n",
        "```\n",
        "\n",
        "## Removing Keys\n",
        "\n",
        "**Python:**\n",
        "```python\n",
        "del person[\"city\"]              # Modifies in place\n",
        "person.pop(\"age\", None)         # Returns value, with default\n",
        "```\n",
        "\n",
        "**Elixir:**\n",
        "```elixir\n",
        "updated_person = Map.delete(person, \"city\")    # Returns new map\n",
        "{value, updated_person} = Map.pop(person, \"age\", nil)  # Returns {value, new_map}\n",
        "```\n",
        "\n",
        "## Getting All Keys/Values\n",
        "\n",
        "**Python:**\n",
        "```python\n",
        "keys = list(person.keys())\n",
        "values = list(person.values())\n",
        "items = list(person.items())    # [(key, value), ...]\n",
        "```\n",
        "\n",
        "**Elixir:**\n",
        "```elixir\n",
        "keys = Map.keys(person)\n",
        "values = Map.values(person)\n",
        "# No direct equivalent to items() - use Enum.to_list/1 if needed\n",
        "```\n",
        "\n",
        "## Merging Maps\n",
        "\n",
        "**Python:**\n",
        "```python\n",
        "defaults = {\"theme\": \"dark\", \"notifications\": True}\n",
        "user_prefs = {\"theme\": \"light\", }\n",
        "settings = {**defaults, **user_prefs}  # user_prefs overrides defaults\n",
        "```\n",
        "\n",
        "**Elixir:**\n",
        "```elixir\n",
        "defaults = %{\"theme\" => \"dark\", \"notifications\" => true}\n",
        "user_prefs = %{\"theme\" => \"light\", }\n",
        "settings = Map.merge(defaults, user_prefs)  # same behaviour as python\n",
        "```\n",
        "\n",
        "## Pattern Matching (Elixir Exclusive)\n",
        "\n",
        "**Python (traditional approach):**\n",
        "```python\n",
        "def greet_person(person):\n",
        "    if person.get(\"name\"):\n",
        "        return f\"Hello, {person['name']}!\"\n",
        "    return \"Hello, stranger!\"\n",
        "```\n",
        "\n",
        "**Elixir (with pattern matching):**\n",
        "\n",
        "```elixir\n",
        "def greet_person(%{\"name\" => name}), do: \"Hello, #{name}!\"\n",
        "def greet_person(_), do: \"Hello, stranger!\"\n",
        "```\n",
        "\n",
        "## Key Differences\n",
        "\n",
        "- **Syntax**: Python uses `{}` , Elixir uses `%{}`\n",
        "- **Mutability**: Python dictionaries are mutable (modify in place), Elixir maps are immutable (return new maps)\n",
        "- **Atom vs String Keys**: Elixir atom keys (`%{key: value}`) enable dot notation access and cleaner syntax, while string keys (`%{\"key\" => value}`) are better for external data\n",
        "\n",
        "## Atom Keys vs String Keys\n",
        "\n",
        "**Use atom keys when:**\n",
        "- Working with internal application data structures\n",
        "- You know the keys at compile time\n",
        "- You want cleaner, more readable code with dot notation\n",
        "\n",
        "**Use string keys when:**\n",
        "- Receiving data from external sources (JSON, APIs)\n",
        "- Keys are dynamic or come from user input\n",
        "- Interfacing with external systems\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "that is great - so, you have used an example where pattern matching is done on function args - that is intriguing. I think you have not covered this before.\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "You're absolutely right! I introduced pattern matching in function arguments without explaining it first - that's a sneak peek of a powerful Elixir feature we haven't covered yet.\n",
        "\n",
        "In that example:\n",
        "```elixir\n",
        "def greet_person(%{\"name\" => name}), do: \"Hello, #{name}!\"\n",
        "def greet_person(_), do: \"Hello, stranger!\"\n",
        "```\n",
        "\n",
        "What's happening is:\n",
        "- **First function clause**: Only matches if the argument is a map with a \"name\" key, and extracts that value into the variable `name`\n",
        "- **Second function clause**: Matches anything else (the `_` means \"I don't care what this is\")\n",
        "\n",
        "This is **function clause pattern matching** - you can define multiple versions of the same function that handle different patterns of input. Elixir automatically chooses the right one based on what you pass in.\n",
        "\n",
        "But you're right - we should cover this properly! This is part of **\"Pattern Matching in Practice\"** from our roadmap.\n",
        "\n",
        "For now, let's stick with basic maps and get comfortable with the syntax. Try the 10 exercises that will help you firmly plant the differences in syntax in Elixir for maps. \n",
        "\n",
        "### Elixir Map Practice Exercises\n",
        "\n",
        "*Practice your map manipulation skills with these graded exercises*\n",
        "\n",
        "Welcome to your Elixir map practice session! These exercises are designed to help you build confidence working with maps and the Enum module. Start with the easier problems and work your way up to more challenging ones.\n",
        "\n",
        "## 🎯 Quick Reference\n",
        "\n",
        "As you work through these exercises, remember:\n",
        "\n",
        "- **`Enum.map/2`** - Transform each element\n",
        "- **`Enum.filter/2`** - Select elements that match a condition  \n",
        "- **`Enum.reduce/3`** - Combine all elements into a single value\n",
        "\n",
        "### Common Patterns You'll Use:\n",
        "\n",
        "```elixir\n",
        "# Access a field\n",
        "employee.name  # or employee[:name]\n",
        "\n",
        "# Create a new map\n",
        "%{name: employee.name, salary: employee.salary}\n",
        "\n",
        "# Update an existing map\n",
        "%{employee | salary: new_salary}\n",
        "\n",
        "# Chain operations\n",
        "data |> filter(...) |> map(...) |> reduce(...)\n",
        "```\n",
        "\n",
        "---\n",
        "\n",
        "## Setup Data\n",
        "\n",
        "Copy this employee data into your Elixir session - you'll use it for all exercises:\n",
        "\n",
        "```elixir\n",
        "employees = [\n",
        "  %{name: \"Alice\", department: \"Engineering\", salary: 85000, experience: 5},\n",
        "  %{name: \"Bob\", department: \"Marketing\", salary: 65000, experience: 3},\n",
        "  %{name: \"Carol\", department: \"Engineering\", salary: 95000, experience: 8},\n",
        "  %{name: \"Dave\", department: \"Sales\", salary: 70000, experience: 4},\n",
        "  %{name: \"Frank\", department: \"Marketing\", salary: 82000, experience: 6},\n",
        "  %{name: \"Eve\", department: \"Engineering\", salary: 78000, experience: 2},\n",
        "]\n",
        "```\n",
        "\n",
        "\n",
        "### Exercise 1: Your First Map Transformation\n",
        "**Goal:** Get comfortable with `Enum.map/2`\n",
        "\n",
        "Create a new list that contains only the names of all employees.\n",
        "\n",
        "**What you should get:**\n",
        "```elixir\n",
        "[\"Alice\", \"Bob\", \"Carol\", \"Dave\", \"Frank\", \"Eve\"]\n",
        "```\n",
        "\n",
        "**Try it yourself first!** Then check your answer below.\n",
        "\n",
        "**💡 Hint:** Use `Enum.map/2` and access the `:name` field from each employee map.\n",
        "\n",
        "**✅ Solution:**\n",
        "```elixir\n",
        "Enum.map(employees, fn employee -> employee.name end)\n",
        "\n",
        "# Or using the shorthand:\n",
        "Enum.map(employees, & &1.name)\n",
        "\n",
        "# piping\n",
        "employees |> Enum.map(fn x -> x.name end) \n",
        "\n",
        "```\n",
        "\n",
        "---\n",
        "\n",
        "### Exercise 2: Simple Filtering\n",
        "**Goal:** Learn basic filtering with `Enum.filter/2`\n",
        "\n",
        "Find all employees who work in the \"Engineering\" department.\n",
        "\n",
        "**What you should get:**\n",
        "```elixir\n",
        "[\n",
        "  %{name: \"Alice\", department: \"Engineering\", salary: 85000, experience: 5},\n",
        "  %{name: \"Carol\", department: \"Engineering\", salary: 95000, experience: 8},\n",
        "  %{name: \"Eve\", department: \"Engineering\", salary: 78000, experience: 2}\n",
        "]\n",
        "```\n",
        "\n",
        "**💡 Hint:** Use `Enum.filter/2` and check if the department equals \"Engineering\".\n",
        "\n",
        "**✅ Solution:**\n",
        "```elixir\n",
        "Enum.filter(employees, fn employee -> \n",
        "  employee.department == \"Engineering\" \n",
        "end)\n",
        "\n",
        "# Or using the shorthand:\n",
        "Enum.filter(employees, &(&1.department == \"Engineering\"))\n",
        "```\n",
        "\n",
        "---\n",
        "\n",
        "### Exercise 3: Basic Math with Reduce\n",
        "**Goal:** Learn to aggregate data with `Enum.reduce/3`\n",
        "\n",
        "Calculate how many total years of experience all employees have combined.\n",
        "\n",
        "**What you should get:** `28`\n",
        "\n",
        "**💡 Hint:** Start with 0 and add each employee's experience to your accumulator.\n",
        "\n",
        "**✅ Solution:**\n",
        "```elixir\n",
        "Enum.reduce(employees, 0, fn employee, total_experience -> \n",
        "  total_experience + employee.experience \n",
        "end)\n",
        "```\n",
        "\n",
        "---\n",
        "\n",
        "### Exercise 4: Creating New Maps\n",
        "**Goal:** Practice creating new map structures\n",
        "\n",
        "Create a list of maps that shows each employee's name and their salary increased by 10%.\n",
        "\n",
        "**What you should get:**\n",
        "```elixir\n",
        "[\n",
        "  %{name: \"Alice\", new_salary: 93500.0},\n",
        "  %{name: \"Bob\", new_salary: 71500.0},\n",
        "  # ... and so on\n",
        "]\n",
        "```\n",
        "\n",
        "**💡 Hint:** Use `Enum.map/2` to create completely new maps with just the name and calculated salary.\n",
        "\n",
        "**✅ Solution:**\n",
        "```elixir\n",
        "Enum.map(employees, fn employee ->\n",
        "  %{name: employee.name, new_salary: employee.salary * 1.1}\n",
        "end)\n",
        "```\n",
        "\n",
        "---\n",
        "\n",
        "### Exercise 5: Combining Filter and Map\n",
        "**Goal:** Chain operations together\n",
        "\n",
        "Get the names of all employees who earn more than $75,000, and sort them alphabetically.\n",
        "\n",
        "**What you should get:** `[\"Alice\", \"Carol\", \"Eve\", \"Frank\"]`\n",
        "\n",
        "**💡 Hint:** You'll need three steps: filter by salary, map to get names, then sort.\n",
        "\n",
        "**✅ Solution:**\n",
        "```elixir\n",
        "employees\n",
        "|> Enum.filter(&(&1.salary > 75000))\n",
        "|> Enum.map(& &1.name)\n",
        "|> Enum.sort()\n",
        "```\n",
        "\n",
        "---\n",
        "\n",
        "## Tuples\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "That is great - what is next?\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Excellent! Now that you've practiced maps, let's move on to **Tuples** - the other essential data structure you'll see constantly in Phoenix.\n",
        "\n",
        "## Tuples in Elixir vs Python\n",
        "\n",
        "Tuples are ordered collections of elements, but they serve different purposes in each language.\n",
        "\n",
        "## Creating and Using Tuples\n",
        "\n",
        "**Python:**\n",
        "```python\n",
        "# Creating tuples\n",
        "point = (3, 4)\n",
        "person = (\"Alice\", 30, \"Engineer\")\n",
        "empty_tuple = ()\n",
        "single_item = (42,)  # Note the comma!\n",
        "\n",
        "# Accessing elements (by index)\n",
        "x = point[0]  # 3\n",
        "y = point[1]  # 4\n",
        "```\n",
        "\n",
        "**Elixir:**\n",
        "```elixir\n",
        "# Creating tuples  \n",
        "point = {3, 4}\n",
        "person = {\"Alice\", 30, \"Engineer\"}\n",
        "empty_tuple = {}\n",
        "single_item = {42}  # No comma needed\n",
        "\n",
        "# Accessing elements (by pattern matching most of the time, not index)\n",
        "{x, y} = point  # x = 3, y = 4\n",
        "{name, age, job} = person  # name = \"Alice\", age = 30, job = \"Engineer\"\n",
        "\n",
        "# if you really want index acces, then you still have it \n",
        "elem(person, 0 ) #> \"Alice\"\n",
        "```\n",
        "\n",
        "## Key Difference: Usage Philosophy\n",
        "\n",
        "**Python tuples** are often used like immutable lists:\n",
        "```python\n",
        "coordinates = [(1, 2), (3, 4), (5, 6)]\n",
        "for x, y in coordinates:\n",
        "    print(f\"Point: {x}, {y}\")\n",
        "```\n",
        "\n",
        "**Elixir tuples** are used for **fixed-size, structured data** with **meaning**.\n",
        "That is why accessing the elements using index is not supported. \n",
        "The expectation is that there is a structured list of items in a certain order inside the tuple and you will use pattern matching to extract it. \n",
        "\n",
        "```elixir\n",
        "# Return values with status\n",
        "{:ok, user} = create_user(\"Alice\")\n",
        "{:error, reason} = create_user(\"\") \n",
        "\n",
        "# Coordinates  \n",
        "{x, y} = {10, 20}\n",
        "\n",
        "# RGB colors\n",
        "{r, g, b} = {255, 128, 0}\n",
        "```\n",
        "\n",
        "## The Phoenix Pattern: Status Tuples\n",
        "\n",
        "This is the pattern you'll see everywhere in Phoenix:\n",
        "\n",
        "```elixir\n",
        "# Success case\n",
        "{:ok, user} = User.create(%{name: \"Alice\", email: \"alice@example.com\"})\n",
        "\n",
        "# Error case  \n",
        "{:error, changeset} = User.create(%{name: \"\", email: \"invalid\"})\n",
        "```\n",
        "\n",
        "Try creating a few tuples in iex and pattern matching them:\n",
        "\n",
        "```elixir\n",
        "# Try these in iex:\n",
        "result = {:ok, \"Success!\"}\n",
        "{status, message} = result\n",
        "\n",
        "error = {:error, \"Something went wrong\"}\n",
        "{:error, reason} = error\n",
        "```\n",
        "\n",
        "What do you get when you run these? Examine the values of message and reason and see whether they match your expectation.\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "Yes they work as expected. Can we do some exercises using tuples?\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "## 🎯 Multiple Function Clauses\n",
        "\n",
        "Before we dive into the exercises, let's learn a powerful Elixir feature: **multiple function clauses in anonymous functions**. This is especially useful when working with tuples that follow patterns like `:ok/:error`.\n",
        "\n",
        "### The Problem with Simple Conditions\n",
        "\n",
        "You've learned to filter lists using simple conditions:\n",
        "\n",
        "```elixir\n",
        "# Simple filtering - works great for basic conditions\n",
        "Enum.filter([1, 2, 3, 4, 5], fn x -> x > 3 end)\n",
        "# Result: [4, 5]\n",
        "```\n",
        "\n",
        "But with tuples like `{:ok, data}` and `{:error, message}`, checking conditions gets awkward:\n",
        "\n",
        "```elixir\n",
        "# Awkward way to filter for :ok tuples\n",
        "Enum.filter(api_responses, fn response -> \n",
        "  elem(response, 0) == :ok \n",
        "end)\n",
        "```\n",
        "\n",
        "### The Elegant Solution: Multiple Function Clauses\n",
        "\n",
        "Instead, Elixir lets you write **multiple clauses** in your anonymous function, each handling a different pattern:\n",
        "\n",
        "```elixir\n",
        "Enum.filter(api_responses, fn\n",
        "  {:ok, _} -> true      # If it matches {:ok, anything}, return true\n",
        "  {:error, _} -> false  # If it matches {:error, anything}, return false\n",
        "end)\n",
        "```\n",
        "\n",
        "### How It Works\n",
        "\n",
        "1. **Pattern Matching**: Each clause tries to match the input against its pattern\n",
        "2. **First Match Wins**: Elixir uses the first clause that matches\n",
        "3. **Automatic Destructuring**: The `_` means \"match anything but don't store it\"\n",
        "\n",
        "### More Examples\n",
        "\n",
        "```elixir\n",
        "# Extract data based on tuple type\n",
        "Enum.map(responses, fn\n",
        "  {:ok, data} -> data           # Extract the data part\n",
        "  {:error, msg} -> \"Error: #{msg}\"  # Transform error to string\n",
        "end)\n",
        "\n",
        "# Count different types\n",
        "Enum.reduce(responses, %{good: 0, bad: 0}, fn\n",
        "  {:ok, _}, acc -> %{acc | good: acc.good + 1}\n",
        "  {:error, _}, acc -> %{acc | bad: acc.bad + 1}\n",
        "end)\n",
        "```\n",
        "\n",
        "### Why This is Powerful\n",
        "\n",
        "- **Readable**: Each case is clearly separate\n",
        "- **Safe**: Elixir ensures all patterns are handled\n",
        "- **Flexible**: Easy to add new tuple types later\n",
        "\n",
        "Now let's practice this technique!\n",
        "\n",
        "---\n",
        "\n",
        "## Setup Data\n",
        "\n",
        "Copy this data into your Elixir session:\n",
        "\n",
        "```elixir\n",
        "# API responses (simulating web service calls)\n",
        "api_responses = [\n",
        "  {:ok, %{id: 1, name: \"Alice\", email: \"alice@example.com\"}},\n",
        "  {:error, \"Invalid email format\"},\n",
        "  {:ok, %{id: 2, name: \"Bob\", email: \"bob@example.com\"}},\n",
        "  {:error, \"User already exists\"},\n",
        "  {:ok, %{id: 3, name: \"Carol\", email: \"carol@example.com\"}}\n",
        "]\n",
        "```\n",
        "\n",
        "---\n",
        "\n",
        "## Exercise 1: Filter Successful Results\n",
        "\n",
        "**Goal:** Work with tuple pattern matching\n",
        "\n",
        "From the `api_responses` list, get only the successful responses (those that start with `:ok`).\n",
        "\n",
        "**What you should get:**\n",
        "\n",
        "```elixir\n",
        "[\n",
        "  {:ok, %{id: 1, name: \"Alice\", email: \"alice@example.com\"}},\n",
        "  {:ok, %{id: 2, name: \"Bob\", email: \"bob@example.com\"}},\n",
        "  {:ok, %{id: 3, name: \"Carol\", email: \"carol@example.com\"}}\n",
        "]\n",
        "```\n",
        "\n",
        "**💡 Hint:** Use `Enum.filter/2` and pattern match on the first element of each tuple.\n",
        "\n",
        "**✅ Solution:**\n",
        "\n",
        "```elixir\n",
        "Enum.filter(api_responses, fn\n",
        "  {:ok, _} -> true\n",
        "  {:error, _} -> false\n",
        "end)\n",
        "```\n",
        "\n",
        "---\n",
        "\n",
        "## Exercise 2: Extract User Data\n",
        "\n",
        "**Goal:** Combine filtering and mapping\n",
        "\n",
        "From the `api_responses`, get only the user data (maps) from successful responses.\n",
        "\n",
        "**What you should get:**\n",
        "\n",
        "```elixir\n",
        "[\n",
        "  %{id: 1, name: \"Alice\", email: \"alice@example.com\"},\n",
        "  %{id: 2, name: \"Bob\", email: \"bob@example.com\"},\n",
        "  %{id: 3, name: \"Carol\", email: \"carol@example.com\"}\n",
        "]\n",
        "```\n",
        "\n",
        "**💡 Hint:** Filter for `:ok` responses, then map to extract just the data part.\n",
        "\n",
        "**✅ Solution:**\n",
        "\n",
        "```elixir\n",
        "api_responses\n",
        "|> Enum.filter(fn {:ok, _} -> true; {:error, _} -> false end)\n",
        "|> Enum.map(fn {:ok, data} -> data end)\n",
        "```\n",
        "\n",
        "---\n",
        "\n",
        "## Exercise 3: Count Success vs Error\n",
        "\n",
        "**Goal:** Analyze tuple patterns with reduce\n",
        "\n",
        "Count how many successful vs error responses you have in `api_responses`.\n",
        "\n",
        "**What you should get:** `%{success: 3, errors: 2}`\n",
        "\n",
        "**💡 Hint:** Use `Enum.reduce/3` with pattern matching in the function clauses.\n",
        "\n",
        "**✅ Solution:**\n",
        "\n",
        "```elixir\n",
        "Enum.reduce(api_responses, %{success: 0, errors: 0}, fn\n",
        "  {:ok, _}, acc -> %{acc | success: acc.success + 1}\n",
        "  {:error, _}, acc -> %{acc | errors: acc.errors + 1}\n",
        "end)\n",
        "```\n",
        "\n",
        "---\n",
        "\n",
        "## Exercise 4: Collect Error Messages\n",
        "\n",
        "**Goal:** Extract specific data from error tuples\n",
        "\n",
        "Get all the error messages from failed responses in `api_responses`.\n",
        "\n",
        "**What you should get:** `[\"Invalid email format\", \"User already exists\"]`\n",
        "\n",
        "**💡 Hint:** Filter for `:error` tuples, then map to extract the messages.\n",
        "\n",
        "**✅ Solution:**\n",
        "\n",
        "```elixir\n",
        "api_responses\n",
        "|> Enum.filter(fn {:error, _} -> true; {:ok, _} -> false end)\n",
        "|> Enum.map(fn {:error, message} -> message end)\n",
        "```\n",
        "\n",
        "---\n",
        "\n",
        "## Exercise 5: Transform to Status Report\n",
        "\n",
        "**Goal:** Create a comprehensive summary\n",
        "\n",
        "Transform the `api_responses` into a status report that shows total requests, successful user IDs, and error messages.\n",
        "\n",
        "**What you should get:**\n",
        "\n",
        "```elixir\n",
        "%{\n",
        "  total_requests: 5,\n",
        "  successful_user_ids: [3, 2, 1],\n",
        "  error_messages: [\"User already exists\", \"Invalid email format\"]\n",
        "}\n",
        "```\n",
        "\n",
        "**💡 Hint:** Use `Enum.reduce/3` with pattern matching to build up the report map.\n",
        "\n",
        "**✅ Solution:**\n",
        "\n",
        "```elixir\n",
        "Enum.reduce(api_responses, %{total_requests: 0, successful_user_ids: [], error_messages: []}, fn\n",
        "  {:ok, user}, acc -> \n",
        "    %{acc | \n",
        "      total_requests: acc.total_requests + 1,\n",
        "      successful_user_ids: [user.id | acc.successful_user_ids]\n",
        "    }\n",
        "  {:error, message}, acc -> \n",
        "    %{acc | \n",
        "      total_requests: acc.total_requests + 1,\n",
        "      error_messages: [message | acc.error_messages]\n",
        "    }\n",
        "end)\n",
        "```\n",
        "\n",
        "---\n",
        "\n",
        "## 🎉 Key Takeaways\n",
        "\n",
        "After completing these exercises, you should understand:\n",
        "\n",
        "1. **Multiple Function Clauses**: How to write `fn pattern1 -> result1; pattern2 -> result2 end`\n",
        "2. **Pattern Matching**: How `{:ok, _}` matches any 2-tuple starting with `:ok`\n",
        "3. **Real-World Patterns**: How Phoenix/Elixir commonly uses `{:ok, data}` and `{:error, reason}` tuples\n",
        "4. **Destructuring**: How to extract data directly in the pattern: `{:ok, user}` gives you access to `user`\n",
        "\n",
        "This pattern matching approach makes your code more readable, safer, and more \"Elixir-like\" than using conditional statements!\n",
        "\n",
        "## Keyword Lists\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "that is great - let us cover keyword lists.\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "# Keyword Lists in Elixir vs Python\n",
        "\n",
        "Keyword lists are a special type of list in Elixir that store key-value pairs. They're similar to Python's dictionaries but with important differences.\n",
        "\n",
        "## Creating Keyword Lists\n",
        "\n",
        "**Python (dictionaries):**\n",
        "```python\n",
        "# Creating dictionaries\n",
        "config = {\"host\": \"localhost\", \"port\": 3000, \"ssl\": True}\n",
        "html_attrs = {\"class\": \"btn\", \"id\": \"submit\", \"disabled\": True}\n",
        "```\n",
        "\n",
        "**Elixir (keyword lists):**\n",
        "```elixir\n",
        "# Creating keyword lists - two syntaxes\n",
        "config = [host: \"localhost\", port: 3000, ssl: true]\n",
        "config = [{:host, \"localhost\"}, {:port, 3000}, {:ssl, true}]  # Explicit syntax\n",
        "\n",
        "html_attrs = [class: \"btn\", id: \"submit\", disabled: true]\n",
        "```\n",
        "\n",
        "## Accessing Values\n",
        "\n",
        "**Python:**\n",
        "```python\n",
        "host = config[\"host\"]\n",
        "port = config.get(\"port\", 8080)  # With default\n",
        "```\n",
        "\n",
        "**Elixir:**\n",
        "```elixir\n",
        "host = config[:host]              # Returns \"localhost\"\n",
        "port = Keyword.get(config, :port, 8080)  # With default\n",
        "```\n",
        "\n",
        "## Key Differences from Maps\n",
        "\n",
        "**Maps (unique keys):**\n",
        "```elixir\n",
        "map = %{name: \"Alice\", name: \"Bob\"}  # Second \"name\" overwrites first\n",
        "# Result: %{name: \"Bob\"}\n",
        "```\n",
        "\n",
        "**Keyword Lists (duplicate keys allowed):**\n",
        "```elixir\n",
        "keyword_list = [name: \"Alice\", age: 30, name: \"Bob\"]  # Duplicates OK!\n",
        "# Result: [name: \"Alice\", age: 30, name: \"Bob\"]\n",
        "\n",
        "# First match wins when accessing\n",
        "keyword_list[:name]  # Returns \"Alice\" (first occurrence)\n",
        "```\n",
        "\n",
        "## When to Use Keyword Lists vs Maps\n",
        "\n",
        "**Use Keyword Lists when:**\n",
        "- Function options/configuration\n",
        "- HTML attributes (can have duplicates)\n",
        "- Order matters\n",
        "- You need duplicate keys\n",
        "\n",
        "**Use Maps when:**\n",
        "- Data modeling\n",
        "- Unique keys required\n",
        "- Fast key lookups needed\n",
        "\n",
        "## Phoenix Examples\n",
        "\n",
        "You'll see keyword lists everywhere in Phoenix for configuration and options:\n",
        "\n",
        "**Function options:**\n",
        "```elixir\n",
        "# Phoenix route helpers\n",
        "user_path(conn, :show, user, [format: :json, locale: \"en\"])\n",
        "\n",
        "# Ecto queries\n",
        "User |> where([u], u.active == true) |> limit(10)\n",
        "```\n",
        "\n",
        "**HTML attributes:**\n",
        "```elixir\n",
        "# Phoenix templates\n",
        "text_input(form, :name, [class: \"form-control\", placeholder: \"Enter name\"])\n",
        "```\n",
        "\n",
        "**Configuration:**\n",
        "```elixir\n",
        "# Phoenix configuration\n",
        "config :my_app, MyApp.Repo,\n",
        "  username: \"postgres\",\n",
        "  password: \"secret\", \n",
        "  database: \"my_app_dev\",\n",
        "  hostname: \"localhost\"\n",
        "```\n",
        "\n",
        "Try these examples in iex:\n",
        "\n",
        "```elixir\n",
        "# Create a keyword list for HTML attributes\n",
        "attrs = [class: \"btn btn-primary\", id: \"submit\", disabled: false]\n",
        "\n",
        "# Access values\n",
        "attrs[:class]\n",
        "Keyword.get(attrs, :type, \"button\")  # With default\n",
        "\n",
        "# Add more attributes (duplicates allowed)\n",
        "new_attrs = [class: \"btn-large\"] ++ attrs\n",
        "```\n",
        "\n",
        "What do you get when you run these?\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "yes they work as expected - please give me 3 meaningful exercises.\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "# Keyword List Practice Exercises\n",
        "\n",
        "*Practice working with keyword lists and Phoenix-style configurations*\n",
        "\n",
        "## Setup Data\n",
        "\n",
        "Copy this data into your Elixir session:\n",
        "\n",
        "```elixir\n",
        "# Phoenix-style form configurations\n",
        "form_configs = [\n",
        "  [field: :name, type: :text, class: \"form-control\", required: true],\n",
        "  [field: :email, type: :email, class: \"form-control\", placeholder: \"Enter email\"],\n",
        "  [field: :age, type: :number, class: \"form-control\", min: 18, max: 100],\n",
        "  [field: :submit, type: :submit, class: \"btn btn-primary\", value: \"Save User\"]\n",
        "]\n",
        "```\n",
        "\n",
        "---\n",
        "\n",
        "## Exercise 1: Extract Form Field Names\n",
        "**Goal:** Work with keyword list access\n",
        "\n",
        "Extract all the field names from the `form_configs`.\n",
        "\n",
        "**What you should get:** `[:name, :email, :age, :submit]`\n",
        "\n",
        "**💡 Hint:** Use `Enum.map/2` and access the `:field` key from each keyword list.\n",
        "\n",
        "**✅ Solution:**\n",
        "```elixir\n",
        "Enum.map(form_configs, &(&1[:field]))\n",
        "\n",
        "# Or more explicitly:\n",
        "Enum.map(form_configs, fn config -> config[:field] end)\n",
        "```\n",
        "\n",
        "---\n",
        "\n",
        "## Exercise 2: Filter Input Fields Only\n",
        "**Goal:** Filter based on keyword list values\n",
        "\n",
        "Get only the form configurations that are input fields (not submit buttons). Filter out any field where `type` is `:submit`.\n",
        "\n",
        "**What you should get:**\n",
        "```elixir\n",
        "[\n",
        "  [field: :name, type: :text, class: \"form-control\", required: true],\n",
        "  [field: :email, type: :email, class: \"form-control\", placeholder: \"Enter email\"],\n",
        "  [field: :age, type: :number, class: \"form-control\", min: 18, max: 100]\n",
        "]\n",
        "```\n",
        "\n",
        "**💡 Hint:** Use `Enum.filter/2` and check if the `:type` is not equal to `:submit`.\n",
        "\n",
        "**✅ Solution:**\n",
        "```elixir\n",
        "Enum.filter(form_configs, fn config -> \n",
        "  config[:type] != :submit \n",
        "end)\n",
        "```\n",
        "\n",
        "---\n",
        "\n",
        "## Exercise 3: Build HTML Attributes String\n",
        "**Goal:** Transform keyword lists into strings\n",
        "\n",
        "For each form configuration, create a string that could be used as HTML attributes. Include `type`, `class`, and any other attributes (but skip `field`).\n",
        "\n",
        "**What you should get:**\n",
        "```elixir\n",
        "[\n",
        "  \"type=\\\"text\\\" class=\\\"form-control\\\" required=\\\"true\\\"\",\n",
        "  \"type=\\\"email\\\" class=\\\"form-control\\\" placeholder=\\\"Enter email\\\"\", \n",
        "  \"type=\\\"number\\\" class=\\\"form-control\\\" min=\\\"18\\\" max=\\\"100\\\"\",\n",
        "  \"type=\\\"submit\\\" class=\\\"btn btn-primary\\\" value=\\\"Save User\\\"\"\n",
        "]\n",
        "```\n",
        "\n",
        "**💡 Hint:** Use `Enum.map/2` to transform each config. Filter out the `:field` key, then build a string from the remaining key-value pairs.\n",
        "\n",
        "**✅ Solution:**\n",
        "```elixir\n",
        "Enum.map(form_configs, fn config ->\n",
        "  config\n",
        "  |> Keyword.delete(:field)  # Remove the field key\n",
        "  |> Enum.map(fn {key, value} -> \"#{key}=\\\"#{value}\\\"\" end)\n",
        "  |> Enum.join(\" \")\n",
        "end)\n",
        "```\n",
        "\n",
        "These exercises show you the practical Phoenix patterns you'll encounter: extracting field information, filtering configurations, and building HTML attributes from keyword lists!\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "that is great. I am happy to see examples relevant to phoenix. Is that all with the data structures or do we have more?\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Great question! We've covered the **essential three** data structures you'll use 90% of the time in Phoenix:\n",
        "\n",
        "✅ **Lists** - `[1, 2, 3]` (collections, sequences)  \n",
        "✅ **Maps** - `%{key: value}` (data modeling, JSON)  \n",
        "✅ **Tuples** - `{:ok, result}` (status returns, fixed structures)  \n",
        "✅ **Keyword Lists** - `[key: value]` (options, HTML attributes)  \n",
        "\n",
        "## Other Data Structures (Less Common)\n",
        "\n",
        "There are a few more, but they're used in specific situations:\n",
        "\n",
        "**Structs** - Like maps but with predefined fields (you'll see these in Phoenix for schemas)\n",
        "```elixir\n",
        "%User{name: \"Alice\", email: \"alice@example.com\"}\n",
        "```\n",
        "\n",
        "**Binaries/Strings** - We've been using these, but there's more depth\n",
        "```elixir\n",
        "<<\"hello\">>  # Binary representation\n",
        "```\n",
        "\n",
        "**Ranges** - For sequences\n",
        "```elixir\n",
        "1..10  # Range from 1 to 10\n",
        "```\n",
        "\n",
        "## My Recommendation\n",
        "\n",
        "Let's **move on to control flow** next! You have solid data structure knowledge for Phoenix. The patterns you'll need most are:\n",
        "\n",
        "1. **case** statements (handling those `{:ok, result}` tuples)\n",
        "2. **with** statements (chaining operations that might fail)  \n",
        "3. **Function clauses** (multiple function definitions with pattern matching)\n",
        "\n",
        "These will help you understand Phoenix's error handling and request processing patterns.\n",
        "\n",
        "**Ready to tackle `case` statements?** They're perfect for handling the tuple patterns you just practiced!\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "## Structs\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "let us cover Structs and then wrap up data structures.\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "# Structs in Elixir\n",
        "\n",
        "Structs are like maps with superpowers - they have predefined fields and belong to a specific module. Think of them as \"typed maps\" that give you more structure and safety.\n",
        "\n",
        "## Structs vs Maps vs Python Classes\n",
        "\n",
        "**Python classes:**\n",
        "```python\n",
        "class User:\n",
        "    def __init__(self, name, email, age=None):\n",
        "        self.name = name\n",
        "        self.email = email\n",
        "        self.age = age\n",
        "\n",
        "user = User(\"Alice\", \"alice@example.com\", 30)\n",
        "print(user.name)  # \"Alice\"\n",
        "```\n",
        "\n",
        "**Elixir maps (what we've been using):**\n",
        "```elixir\n",
        "user = %{name: \"Alice\", email: \"alice@example.com\", age: 30}\n",
        "user.name  # \"Alice\"\n",
        "```\n",
        "\n",
        "**Elixir structs:**\n",
        "```elixir\n",
        "# First, define the struct\n",
        "defmodule User do\n",
        "  defstruct [:name, :email, :age]\n",
        "end\n",
        "\n",
        "# Then create instances\n",
        "user = %User{name: \"Alice\", email: \"alice@example.com\", age: 30}\n",
        "user.name  # \"Alice\"\n",
        "```\n",
        "\n",
        "## Defining Structs\n",
        "\n",
        "```elixir\n",
        "defmodule BlogPost do\n",
        "  defstruct [:title, :content, :author, published: false, views: 0]\n",
        "  #         ↑ required fields    ↑ fields with defaults\n",
        "end\n",
        "```\n",
        "\n",
        "## Creating and Using Structs\n",
        "\n",
        "```elixir\n",
        "# Create a new struct\n",
        "post = %BlogPost{\n",
        "  title: \"Learning Elixir\", \n",
        "  content: \"Elixir is amazing!\",\n",
        "  author: \"Alice\"\n",
        "}\n",
        "# published: false, views: 0 (defaults)\n",
        "\n",
        "# Access fields (same as maps)\n",
        "post.title  # \"Learning Elixir\"\n",
        "post.published  # false\n",
        "\n",
        "# Update fields (same as maps)\n",
        "published_post = %{post | published: true, views: 100}\n",
        "```\n",
        "\n",
        "## Key Advantages of Structs\n",
        "\n",
        "**1. Field Validation:**\n",
        "```elixir\n",
        "# This works (all required fields provided)\n",
        "%User{name: \"Alice\", email: \"alice@example.com\"}\n",
        "\n",
        "# This fails at compile time (missing required field)\n",
        "%User{name: \"Alice\"}  # Error: missing required key :email\n",
        "```\n",
        "\n",
        "**2. Pattern Matching:**\n",
        "```elixir\n",
        "def greet_user(%User{name: name}), do: \"Hello, #{name}!\"\n",
        "def greet_user(_), do: \"Hello, stranger!\"\n",
        "\n",
        "# Only matches User structs, not regular maps\n",
        "greet_user(%User{name: \"Alice\"})  # \"Hello, Alice!\"\n",
        "greet_user(%{name: \"Bob\"})        # \"Hello, stranger!\"\n",
        "```\n",
        "\n",
        "**3. Clear Data Contracts:**\n",
        "```elixir\n",
        "# You know exactly what fields a User has\n",
        "# No surprises like with regular maps\n",
        "```\n",
        "\n",
        "## Phoenix Examples\n",
        "\n",
        "In Phoenix, you'll see structs everywhere:\n",
        "\n",
        "**User Schema:**\n",
        "```elixir\n",
        "defmodule MyApp.User do\n",
        "  use Ecto.Schema\n",
        "  \n",
        "  schema \"users\" do\n",
        "    field :name, :string\n",
        "    field :email, :string\n",
        "    field :age, :integer\n",
        "    \n",
        "    timestamps()\n",
        "  end\n",
        "end\n",
        "\n",
        "# Creates a struct like:\n",
        "# %MyApp.User{id: nil, name: nil, email: nil, age: nil, ...}\n",
        "```\n",
        "\n",
        "**Changeset (for form validation):**\n",
        "```elixir\n",
        "changeset = %Ecto.Changeset{\n",
        "  data: %User{},\n",
        "  changes: %{name: \"Alice\"},\n",
        "  errors: [],\n",
        "  valid?: true\n",
        "}\n",
        "```\n",
        "\n",
        "## Try It Yourself\n",
        "\n",
        "Try these in iex:\n",
        "\n",
        "```elixir\n",
        "# Define a simple struct\n",
        "defmodule Task do\n",
        "  defstruct [:title, :description, completed: false, priority: :medium]\n",
        "end\n",
        "\n",
        "# Create some tasks\n",
        "task1 = %Task{title: \"Learn Elixir\", description: \"Study structs\"}\n",
        "task2 = %Task{title: \"Build Phoenix app\", description: \"Create a todo app\", priority: :high}\n",
        "\n",
        "# Update a task\n",
        "completed_task = %{task1 | completed: true}\n",
        "```\n",
        "\n",
        "What do you get when you run these?\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "they work nicely. But what is that message when I tried to execute defmodule. By the way, what is defmodule? You have not yet covered it, I guess. \n",
        "\n",
        "```\n",
        "warning: redefining module Task (current version loaded from /opt/homebrew/Cellar/elixir/1.18.3/lib/elixir/lib/elixir/ebin/Elixir.Task.beam)\n",
        "└─ iex:121: Task (module)\n",
        "\n",
        "{:module, Task,\n",
        " <<70, 79, 82, 49, 0, 0, 9, 244, 66, 69, 65, 77, 65, 116, 85, 56, 0, 0, 0, 247,\n",
        "   0, 0, 0, 22, 11, 69, 108, 105, 120, 105, 114, 46, 84, 97, 115, 107, 8, 95,\n",
        "   95, 105, 110, 102, 111, 95, 95, 10, 97, ...>>,\n",
        " %Task{title: nil, description: nil, completed: false, priority: :medium}}\n",
        "\n",
        "```\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Great observation! You've discovered two important things:\n",
        "\n",
        "## 1. The Warning Message\n",
        "\n",
        "The warning tells you that `Task` is already a built-in Elixir module! Elixir has a `Task` module for running concurrent processes, so when you defined your own `Task` module, you overwrote it.\n",
        "\n",
        "This is like accidentally naming a Python class `list` or `dict` - it works, but shadows the built-in.\n",
        "\n",
        "**Better naming:**\n",
        "```elixir\n",
        "defmodule TodoItem do  # Better name!\n",
        "  defstruct [:title, :description, completed: false, priority: :medium]\n",
        "end\n",
        "```\n",
        "\n",
        "## 2. What is `defmodule`?\n",
        "\n",
        "You're absolutely right - I haven't covered modules yet! I jumped ahead because structs require modules.\n",
        "\n",
        "**Quick explanation:**\n",
        "- `defmodule` creates a new module (like a namespace/container for functions)\n",
        "- Modules organize related functions together\n",
        "- `defstruct` inside a module creates a struct type\n",
        "\n",
        "Think of it like:\n",
        "```python\n",
        "# Python\n",
        "class TodoItem:  # Class definition\n",
        "    def __init__(self, title, description, completed=False):\n",
        "        self.title = title\n",
        "        # etc.\n",
        "```\n",
        "\n",
        "```elixir\n",
        "# Elixir  \n",
        "defmodule TodoItem do  # Module definition\n",
        "  defstruct [:title, :description, completed: false]  # Struct definition\n",
        "end\n",
        "```\n",
        "\n",
        "## The Return Value\n",
        "\n",
        "That long binary output `<<70, 79, 82...>>` is the compiled module bytecode - just ignore it! The important part is the struct at the end showing the default values.\n",
        "\n",
        "**Let's use a safe name:**\n",
        "```elixir\n",
        "defmodule BlogPost do\n",
        "  defstruct [:title, :content, published: false]\n",
        "end\n",
        "\n",
        "post = %BlogPost{title: \"Hello\", content: \"World\"}\n",
        "```\n",
        "\n",
        "Try this version - no warnings!\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "yes they work nicely.\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "Perfect! Now you have a solid understanding of all the essential data structures for Phoenix development:\n",
        "\n",
        "## Data Structures Summary ✅\n",
        "\n",
        "**Lists** - `[1, 2, 3]` - Collections and sequences  \n",
        "**Maps** - `%{key: value}` - General data modeling  \n",
        "**Tuples** - `{:ok, result}` - Status returns and fixed structures  \n",
        "**Keyword Lists** - `[key: value]` - Options and configurations  \n",
        "**Structs** - `%User{name: \"Alice\"}` - Typed data with validation  \n",
        "\n",
        "You now understand:\n",
        "- When to use each data structure\n",
        "- How they compare to Python equivalents\n",
        "- The Phoenix patterns you'll see in real applications\n",
        "- Pattern matching with all of them\n",
        "\n",
        "## Ready for Control Flow!\n",
        "\n",
        "Now let's move on to **control flow** - specifically the patterns that handle all those `{:ok, result}` and `{:error, reason}` tuples you've been practicing with.\n",
        "\n",
        "**Next up: `case` statements** - the elegant way to handle different outcomes in Elixir. This is where pattern matching really shines and where you'll see the Phoenix request/response patterns come together.\n",
        "\n",
        "Ready to learn how to handle success and error cases like a pro?\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "## Control flow\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "please do a high-level summary of control flows and then we can go into a little more detail, one by one.\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "# Control Flow in Elixir - High-Level Overview\n",
        "\n",
        "Control flow in Elixir is fundamentally different from Python because it's built around **pattern matching** and **immutability** rather than traditional imperative constructs.\n",
        "\n",
        "## Python vs Elixir Philosophy\n",
        "\n",
        "**Python (Imperative):**\n",
        "```python\n",
        "# Tell the computer HOW to do things step by step\n",
        "if condition:\n",
        "    do_this()\n",
        "    modify_variable()\n",
        "else:\n",
        "    do_that()\n",
        "    modify_other_variable()\n",
        "```\n",
        "\n",
        "**Elixir (Functional/Declarative):**\n",
        "```elixir\n",
        "# Tell the computer WHAT you want based on data patterns\n",
        "case data do\n",
        "  {:ok, result} -> handle_success(result)\n",
        "  {:error, reason} -> handle_error(reason)\n",
        "end\n",
        "```\n",
        "\n",
        "## The 4 Main Control Flow Constructs\n",
        "\n",
        "### **1. `case` - Pattern Matching Control**\n",
        "**Purpose:** Handle different data patterns  \n",
        "**Python equivalent:** Complex if/elif chains + type checking\n",
        "```elixir\n",
        "case api_call() do\n",
        "  {:ok, user} -> \"Welcome #{user.name}!\"\n",
        "  {:error, :not_found} -> \"User not found\"\n",
        "  {:error, reason} -> \"Error: #{reason}\"\n",
        "end\n",
        "```\n",
        "\n",
        "### **2. `cond` - Condition-Based Control**\n",
        "**Purpose:** Multiple conditions (like if/elif)  \n",
        "**Python equivalent:** if/elif/else chains\n",
        "```elixir\n",
        "cond do\n",
        "  age < 13 -> \"child\"\n",
        "  age < 20 -> \"teenager\"  \n",
        "  age < 65 -> \"adult\"\n",
        "  true -> \"senior\"\n",
        "end\n",
        "```\n",
        "\n",
        "### **3. `with` - Happy Path Programming**\n",
        "**Purpose:** Chain operations that might fail  \n",
        "**Python equivalent:** Nested try/catch or early returns\n",
        "```elixir\n",
        "with {:ok, user} <- get_user(id),\n",
        "     {:ok, account} <- get_account(user),\n",
        "     {:ok, balance} <- check_balance(account) do\n",
        "  {:ok, balance}\n",
        "else\n",
        "  error -> error\n",
        "end\n",
        "```\n",
        "\n",
        "### **4. `if/unless` - Simple Conditions**\n",
        "**Purpose:** Basic true/false decisions  \n",
        "**Python equivalent:** Simple if statements\n",
        "```elixir\n",
        "if user.admin? do\n",
        "  \"Admin access granted\"\n",
        "else\n",
        "  \"Regular user\"\n",
        "end\n",
        "```\n",
        "\n",
        "## Key Differences from Python\n",
        "\n",
        "| Python | Elixir | Why Different? |\n",
        "|--------|--------|----------------|\n",
        "| `if/elif/else` | `case` with patterns | Pattern matching is more powerful |\n",
        "| `try/except` | `case` with tuples | Errors are data, not exceptions |\n",
        "| Multiple returns | Single expression result | Everything is an expression |\n",
        "| Mutation in branches | New data in branches | Immutability |\n",
        "\n",
        "## Phoenix Patterns You'll See\n",
        "\n",
        "**Handling web requests:**\n",
        "```elixir\n",
        "case authenticate_user(token) do\n",
        "  {:ok, user} -> render_dashboard(user)\n",
        "  {:error, :invalid_token} -> redirect_to_login()\n",
        "  {:error, :expired} -> show_refresh_page()\n",
        "end\n",
        "```\n",
        "\n",
        "**Database operations:**\n",
        "```elixir\n",
        "with {:ok, user} <- Users.create(params),\n",
        "     {:ok, _email} <- send_welcome_email(user) do\n",
        "  {:ok, user}\n",
        "else\n",
        "  {:error, changeset} -> {:error, changeset}\n",
        "  error -> {:error, \"Failed to create user\"}\n",
        "end\n",
        "```\n",
        "\n",
        "## Learning Order\n",
        "\n",
        "1. **`case`** - Most important, handles the `{:ok, result}` patterns\n",
        "2. **`with`** - Essential for Phoenix request pipelines  \n",
        "3. **`cond`** - Simple but useful\n",
        "4. **`if/unless`** - You already know this concept\n",
        "\n",
        "**Ready to start with `case` statements?** They're the heart of Elixir's error handling!\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "**AI Prompt**\n",
        "\n",
        "yes - let us start with case statements.\n",
        "\n",
        "**AI Response**\n",
        "\n",
        "# Case Statements in Elixir\n",
        "\n",
        "Case statements are Elixir's most powerful control flow construct. They use pattern matching to decide what to do based on the **shape and content** of your data.\n",
        "\n",
        "## Basic Syntax\n",
        "\n",
        "```elixir\n",
        "case expression do\n",
        "  pattern1 -> result1\n",
        "  pattern2 -> result2\n",
        "  pattern3 -> result3\n",
        "end\n",
        "```\n",
        "\n",
        "## Simple Example vs Python\n",
        "\n",
        "**Python (if/elif/else):**\n",
        "```python\n",
        "def handle_response(status_code):\n",
        "    if status_code == 200:\n",
        "        return \"Success\"\n",
        "    elif status_code == 404:\n",
        "        return \"Not found\"\n",
        "    elif status_code == 500:\n",
        "        return \"Server error\"\n",
        "    else:\n",
        "        return f\"Unknown status: {status_code}\"\n",
        "```\n",
        "\n",
        "**Elixir (case):**\n",
        "```elixir\n",
        "def handle_response(status_code) do\n",
        "  case status_code do\n",
        "    200 -> \"Success\"\n",
        "    404 -> \"Not found\" \n",
        "    500 -> \"Server error\"\n",
        "    code -> \"Unknown status: #{code}\"\n",
        "  end\n",
        "end\n",
        "```\n",
        "\n",
        "## Pattern Matching Power\n",
        "\n",
        "This is where case statements become much more powerful than Python's if/elif:\n",
        "\n",
        "**Matching on data structure:**\n",
        "```elixir\n",
        "case api_response do\n",
        "  {:ok, %{name: name, age: age}} -> \n",
        "    \"User: #{name}, Age: #{age}\"\n",
        "  \n",
        "  {:error, \"not_found\"} -> \n",
        "    \"User doesn't exist\"\n",
        "  \n",
        "  {:error, reason} -> \n",
        "    \"Error occurred: #{reason}\"\n",
        "  \n",
        "  _ -> \n",
        "    \"Unexpected response format\"\n",
        "end\n",
        "```\n",
        "\n",
        "**Python equivalent (much more verbose):**\n",
        "```python\n",
        "if (isinstance(api_response, tuple) and \n",
        "    len(api_response) == 2 and \n",
        "    api_response[0] == \"ok\"):\n",
        "    user_data = api_response[1]\n",
        "    if isinstance(user_data, dict) and \"name\" in user_data:\n",
        "        return f\"User: {user_data['name']}, Age: {user_data.get('age')}\"\n",
        "elif (isinstance(api_response, tuple) and \n",
        "      len(api_response) == 2 and \n",
        "      api_response[0] == \"error\"):\n",
        "    if api_response[1] == \"not_found\":\n",
        "        return \"User doesn't exist\"\n",
        "    else:\n",
        "        return f\"Error occurred: {api_response[1]}\"\n",
        "else:\n",
        "    return \"Unexpected response format\"\n",
        "```\n",
        "\n",
        "## Phoenix Examples\n",
        "\n",
        "**Handling user authentication:**\n",
        "```elixir\n",
        "case authenticate_user(token) do\n",
        "  {:ok, %User{admin: true} = user} -> \n",
        "    render_admin_dashboard(user)\n",
        "  \n",
        "  {:ok, user} -> \n",
        "    render_user_dashboard(user)\n",
        "  \n",
        "  {:error, :invalid_token} -> \n",
        "    redirect_to_login()\n",
        "  \n",
        "  {:error, :expired} -> \n",
        "    show_token_expired_page()\n",
        "end\n",
        "```\n",
        "\n",
        "## Try It Yourself\n",
        "\n",
        "Try these examples in iex:\n",
        "\n",
        "```elixir\n",
        "# Simple number matching\n",
        "age = 25\n",
        "case age do\n",
        "  x when x < 13 -> \"child\"\n",
        "  x when x < 20 -> \"teenager\"\n",
        "  x when x < 65 -> \"adult\"\n",
        "  _ -> \"senior\"\n",
        "end\n",
        "\n",
        "# Tuple pattern matching\n",
        "result = {:ok, \"Success!\"}\n",
        "case result do\n",
        "  {:ok, message} -> \"Great: #{message}\"\n",
        "  {:error, reason} -> \"Failed: #{reason}\"\n",
        "end\n",
        "```\n",
        "\n",
        "What do you get when you run these?\n",
        "\n",
        "<!-- no tool use -->\n",
        "\n",
        "<!-- no tool use -->\n"
      ],
      "id": "298bd386"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/Users/siraj/.local/share/virtualenvs/advent-of-code-2021-1NFDTl2l/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}